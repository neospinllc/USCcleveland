<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Card Sliver Weight Monitoring</title>

  <!-- Only Chart.js required -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
  <!-- Excel export library -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- PDF export library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    /* Reset for Squarespace embedding */
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: transparent;
    }

    html,
    body {
      height: auto;
      min-height: auto;
    }

    /* Container optimized for Squarespace embedding */
    .container {
      max-width: 1950px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
    }

    /* Ensure container doesn't create unwanted spacing when embedded */
    @media (max-width: 768px) {
      .container {
        padding: 15px;
        border-radius: 12px;
      }
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 20px;
      gap: 20px;
    }

    .app-title {
      font-size: 28px;
      font-weight: 700;
      color: #2c3e50;
      text-align: center;
      flex: 1;
    }

    .current-date {
      font-size: 16px;
      color: #7f8c8d;
      text-align: right;
      min-width: 180px;
    }

    .top-inputs {
      display: flex;
      justify-content: space-between;
      gap: 30px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .column {
      flex: 1;
      min-width: 360px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .input-card {
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .input-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12);
    }

    .card-title {
      font-size: 16px;
      font-weight: 650;
      color: #2c3e50;
      margin-bottom: 8px;
    }

    .card-subtitle {
      font-size: 12px;
      color: #7f8c8d;
      margin-top: -4px;
      margin-bottom: 8px;
    }

    .card-input {
      width: 100%;
      padding: 12px 14px;
      font-size: 16px;
      border: none;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.75);
      box-sizing: border-box;
    }

    .card-input:focus {
      outline: none;
      background: white;
    }

    .card-report {
      background: #e3f2fd;
    }

    .card-report .card-input {
      background: #d1e7fd;
    }

    .card-testdate {
      background: #fff0f5;
    }

    .card-testdate .card-input {
      background: #ffe0eb;
    }

    .card-operator {
      background: #f0f4f8;
    }

    .card-operator .card-input {
      background: #e2e8f0;
    }

    .header-inputs-row {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 16px;
      margin-bottom: 16px;
    }

    .products-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 16px;
      margin-top: 0;
    }

    .product-block {
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .product-block:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12);
    }

    .product-qtip {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    }

    .product-triple {
      background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
    }

    .product-organic {
      background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
    }

    .product-special {
      background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
    }

    .product-custom {
      background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
    }

    .product-header {
      margin-bottom: 12px;
    }

    .product-name {
      font-size: 16px;
      font-weight: 700;
      color: #1a237e;
    }

    .product-triple .product-name {
      color: #4a148c;
    }

    .product-organic .product-name {
      color: #1b5e20;
    }

    .product-special .product-name {
      color: #e65100;
    }

    .product-custom .product-name {
      color: #880e4f;
    }

    .product-inputs {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .product-input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .product-input-group label {
      font-size: 13px;
      color: #37474f;
      font-weight: 600;
    }

    .product-input-group .card-input {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .product-input-group .card-input:focus {
      background: white;
      border-color: rgba(0, 0, 0, 0.2);
    }

    /* Product row colors in data entry table */
    .row-qtip {
      background-color: #e3f2fd !important;
    }

    .row-triple {
      background-color: #f3e5f5 !important;
    }

    .row-organic {
      background-color: #e8f5e9 !important;
    }

    .row-special {
      background-color: #fff3e0 !important;
    }

    .row-custom {
      background-color: #fce4ec !important;
    }

    button {
      padding: 12px 22px;
      font-size: 16px;
      margin: 10px;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.25s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.18);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      transform: none !important;
    }

    button:disabled:hover {
      transform: none !important;
      box-shadow: none !important;
    }

    .btn-start {
      background: #3498db;
      color: white;
    }

    .btn-simulate {
      background: #9b59b6;
      color: white;
    }

    .btn-save {
      background: #4CAF50;
      color: white;
    }

    .btn-save:disabled {
      background: #9e9e9e;
      color: #f5f5f5;
    }

    .btn-print {
      background: #27ae60;
      color: white;
    }

    .btn-print:disabled {
      background: #9e9e9e;
      color: #f5f5f5;
    }

    .btn-danger {
      background: #e74c3c;
      color: white;
    }

    .btn-muted {
      background: #64748b;
      color: white;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      font-size: 14px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
      vertical-align: middle;
    }

    thead th {
      background: #f3f4f6;
      font-weight: 700;
    }

    td.avg-cell {
      font-weight: 700;
      background: #f8fafc;
    }

    tr.out-of-control td.avg-cell {
      background: #ffe5e5;
    }

    tr.out-of-control {
      outline: 2px solid #e74c3c;
      outline-offset: -2px;
    }

    .metrics {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 18px 0 6px;
    }

    .metric {
      background: #3498db;
      color: white;
      padding: 16px 18px;
      border-radius: 14px;
      min-width: 240px;
      text-align: center;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.16);
      transition: background 0.3s;
    }

    .metric.out-of-control {
      background: #e74c3c;
    }

    .metric .label {
      font-size: 14px;
      opacity: 0.9;
    }

    .metric .value {
      font-size: 22px;
      font-weight: 800;
      margin-top: 6px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 18px;
      align-items: start;
    }

    @media (max-width: 1200px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }

    .chart-card {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    }

    .chart-card h3 {
      margin: 0 0 10px;
      font-size: 16px;
      color: #2c3e50;
    }

    canvas {
      width: 100% !important;
      height: 360px !important;
    }

    .saved-tests {
      margin-top: 32px;
    }

    .saved-tests h2 {
      margin-top: 0;
    }

    .action-row {
      margin: 12px 0;
      text-align: center;
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .filter-section {
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .filter-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .filter-tab {
      padding: 8px 16px;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .filter-tab:hover {
      background: #f3f4f6;
    }

    .filter-tab.active {
      background: #3498db;
      color: white;
      border-color: #3498db;
    }

    .filter-content {
      display: none;
    }

    .filter-content.active {
      display: block;
    }

    .filter-row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .filter-label {
      font-weight: 600;
      color: #374151;
      min-width: 100px;
    }

    .filter-input {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
    }

    .filter-buttons {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .card-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-height: 150px;
      overflow-y: auto;
      padding: 8px;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 6px;
    }

    .card-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .details-panel {
      margin-top: 18px;
      border: 1px solid #e5e7eb;
      background: #f8fafc;
      border-radius: 16px;
      padding: 16px;
      display: none;
    }

    .details-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .details-title {
      font-weight: 800;
      color: #0f172a;
    }

    .details-meta {
      color: #334155;
      font-size: 14px;
      line-height: 1.5;
    }

    .details-table-wrap {
      margin-top: 10px;
      background: #fff;
      border-radius: 12px;
      padding: 10px;
      border: 1px solid #e5e7eb;
    }

    .error-banner {
      display: none;
      padding: 12px 14px;
      margin: 10px 0 0;
      border-radius: 12px;
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fecaca;
      font-weight: 600;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal-box {
      background: #fff;
      padding: 24px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      text-align: center;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 12px;
      color: #bf0e0e;
      /* Warning color */
    }

    .modal-message {
      font-size: 15px;
      color: #334155;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .btn-modal-cancel {
      background: #e2e8f0;
      color: #334155;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn-modal-confirm {
      background: #bf0e0e;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    /* Print: allow multi-page flow - optimized for minimal header space */
    @media print {
      body * {
        visibility: hidden;
      }

      #printSection,
      #printSection * {
        visibility: visible !important;
      }

      #printSection {
        position: static !important;
        left: auto !important;
        top: auto !important;
        width: 100% !important;
        max-width: 100% !important;
        height: auto !important;
        overflow: visible !important;
        padding: 0 !important;
        margin: 0 !important;
        background: white !important;
        box-sizing: border-box !important;
      }

      /* Minimize print header spacing */
      #printSection>div:first-child {
        padding: 2px 0 !important;
        margin-bottom: 4px !important;
        border-bottom: 1px solid #000 !important;
      }

      .no-print {
        display: none !important;
      }

      .print-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }

      canvas {
        width: 100% !important;
        height: 300px !important;
        max-width: 100% !important;
      }

      .page-break {
        break-before: page;
        page-break-before: always;
      }

      .avoid-break {
        break-inside: avoid;
        page-break-inside: avoid;
      }

      #printTitle {
        font-size: 14px !important;
        margin-bottom: 2px !important;
        padding: 0 !important;
      }

      #printDate {
        font-size: 9px !important;
        margin-bottom: 2px !important;
        padding: 0 !important;
      }

      #printMeta {
        font-size: 9px !important;
        line-height: 1.2 !important;
        margin-bottom: 4px !important;
        padding: 0 !important;
      }

      #printMeta div {
        margin: 0 !important;
        padding: 0 !important;
      }

      #printMetrics {
        margin: 4px 0 !important;
        gap: 4px !important;
        flex-wrap: nowrap !important;
        /* Force single row */
        display: flex !important;
        align-items: stretch !important;
      }

      .print-metric {
        padding: 4px 6px !important;
        border-radius: 4px !important;
        border: 1px solid #ccc !important;
        background: #f1f5f9 !important;
        min-width: 0 !important;
        /* Allow shrinking */
        flex: 1 1 0px !important;
        /* Distribute evenly */
        text-align: center !important;
        color: #333 !important;
        /* Changed from white to a darker color for contrast on light background */
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      .print-metric .label {
        font-size: 8px !important;
        opacity: 1 !important;
        line-height: 1.1 !important;
      }

      .print-metric .value {
        font-size: 12px !important;
        font-weight: 800 !important;
        margin-top: 1px !important;
      }

      .makePrintChartCard {
        padding: 2px !important;
        margin-bottom: 4px !important;
      }

      .makePrintChartCard h3 {
        font-size: 11px !important;
        margin: 1px 0 !important;
      }

      table {
        font-size: 10px !important;
      }

      th,
      td {
        padding: 4px 6px !important;
      }

      #printChartsContainer {
        margin-top: 4px !important;
      }

      #printTablesContainer {
        margin-top: 4px !important;
      }

      /* Minimize page margins for print */
      @page {
        margin: 0.3cm 0.5cm !important;
        size: A4 !important;
      }

      * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
    }
  </style>
</head>

<body>
  <div class="container no-print">
    <div class="header">
      <div style="min-width:180px; color:#7f8c8d; font-weight:600;">SPINWISELY</div>
      <div class="app-title">Card Sliver Weight Monitoring</div>
      <div class="current-date" id="currentDate"></div>
    </div>

    <div id="errorBanner" class="error-banner"></div>

    <h2>New Test</h2>

    <div class="header-inputs-row">
      <div class="input-card card-report">
        <div class="card-title">Report Number</div>
        <div class="card-subtitle">Auto-generated sequence</div>
        <input type="text" id="reportNumber" class="card-input" readonly value="Loading...">
      </div>

      <div class="input-card card-testdate">
        <div class="card-title">Test Date</div>
        <input type="date" id="testDate" class="card-input">
      </div>

      <div class="input-card card-operator">
        <div class="card-title">Operator Name</div>
        <input type="text" id="operatorName" class="card-input" placeholder="e.g., John Doe" list="operatorList"
          required>
        <datalist id="operatorList"></datalist>
      </div>
    </div>

    <div class="products-grid">
      <div class="product-block product-qtip">
        <div class="product-header">
          <span class="product-name">Q tip</span>
        </div>
        <div class="product-inputs">
          <div class="product-input-group">
            <label for="t_qtip">Target (g/m)</label>
            <input id="t_qtip" type="number" step="0.01" class="card-input" placeholder="e.g., 6.50">
          </div>
          <div class="product-input-group">
            <label for="r_qtip">Acceptable Range (%)</label>
            <input id="r_qtip" type="number" min="0.5" max="20" step="0.1" value="5.0" class="card-input"
              placeholder="5.0">
          </div>
          <div class="product-input-group">
            <label for="c_qtip">Cards (e.g. 1-5, 8)</label>
            <input id="c_qtip" type="text" class="card-input" placeholder="e.g. 1-5">
          </div>
        </div>
      </div>

      <div class="product-block product-triple">
        <div class="product-header">
          <span class="product-name">Triple</span>
        </div>
        <div class="product-inputs">
          <div class="product-input-group">
            <label for="t_triple">Target (g/m)</label>
            <input id="t_triple" type="number" step="0.01" class="card-input" placeholder="e.g., 12.50">
          </div>
          <div class="product-input-group">
            <label for="r_triple">Acceptable Range (%)</label>
            <input id="r_triple" type="number" min="0.5" max="20" step="0.1" value="5.0" class="card-input"
              placeholder="5.0">
          </div>
          <div class="product-input-group">
            <label for="c_triple">Cards (e.g. 1-5, 8)</label>
            <input id="c_triple" type="text" class="card-input" placeholder="e.g. 6-10">
          </div>
        </div>
      </div>

      <div class="product-block product-organic">
        <div class="product-header">
          <span class="product-name">Organic</span>
        </div>
        <div class="product-inputs">
          <div class="product-input-group">
            <label for="t_organic">Target (g/m)</label>
            <input id="t_organic" type="number" step="0.01" class="card-input" placeholder="e.g., 4.50">
          </div>
          <div class="product-input-group">
            <label for="r_organic">Acceptable Range (%)</label>
            <input id="r_organic" type="number" min="0.5" max="20" step="0.1" value="5.0" class="card-input"
              placeholder="5.0">
          </div>
          <div class="product-input-group">
            <label for="c_organic">Cards (e.g. 1-5, 8)</label>
            <input id="c_organic" type="text" class="card-input" placeholder="e.g. 11-12">
          </div>
        </div>
      </div>

      <div class="product-block product-special">
        <div class="product-header">
          <span class="product-name">Special</span>
        </div>
        <div class="product-inputs">
          <div class="product-input-group">
            <label for="t_special">Target (g/m)</label>
            <input id="t_special" type="number" step="0.01" class="card-input" placeholder="e.g., 4.50">
          </div>
          <div class="product-input-group">
            <label for="r_special">Acceptable Range (%)</label>
            <input id="r_special" type="number" min="0.5" max="20" step="0.1" value="5.0" class="card-input"
              placeholder="5.0">
          </div>
          <div class="product-input-group">
            <label for="c_special">Cards (e.g. 1-5, 8)</label>
            <input id="c_special" type="text" class="card-input" placeholder="e.g. 13">
          </div>
        </div>
      </div>

      <div class="product-block product-custom">
        <div class="product-header">
          <span class="product-name">Custom Product</span>
        </div>
        <div class="product-inputs">
          <div class="product-input-group">
            <label for="t_custom_name">Product Name</label>
            <input id="t_custom_name" type="text" class="card-input" placeholder="Enter product name">
          </div>
          <div class="product-input-group">
            <label for="t_custom">Target (g/m)</label>
            <input id="t_custom" type="number" step="0.01" class="card-input" placeholder="e.g., 4.50">
          </div>
          <div class="product-input-group">
            <label for="r_custom">Acceptable Range (%)</label>
            <input id="r_custom" type="number" min="0.5" max="20" step="0.1" value="5.0" class="card-input"
              placeholder="5.0">
          </div>
          <div class="product-input-group">
            <label for="c_custom">Cards (e.g. 1-5, 8)</label>
            <input id="c_custom" type="text" class="card-input" placeholder="e.g. 14-15">
          </div>
        </div>
      </div>
    </div>

    <div style="text-align:center; margin: 18px 0 10px;">
      <button class="btn-start" onclick="validateAndStart()">Start Entry</button>
      <button class="btn-simulate" onclick="validateAndSimulate()">Simulate Data</button>
      <button class="btn-danger" onclick="startNewTest()">Start New Test</button>
    </div>

    <div id="testSection" style="display:none;">
      <h2>Data Entry (15 Cards × 4 Coilers)</h2>

      <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
        <div id="scaleStatus"
          style="padding: 8px 12px; border-radius: 8px; background: #f0f0f0; display: none; flex: 1; margin-right: 10px;">
        </div>
        <button onclick="connectScale()" id="scaleBtn"
          style="padding: 8px 16px; font-size: 14px; background: #3498db; color: white; border: none; border-radius: 8px; cursor: pointer;">
          Connect Scale
        </button>
      </div>
      <table id="sliverTable">
        <thead>
          <tr>
            <th>Card #</th>
            <th>Product</th>
            <th>Target (g/m)</th>
            <th>Coiler 1 (g/m)</th>
            <th>Coiler 2 (g/m)</th>
            <th>Coiler 3 (g/m)</th>
            <th>Coiler 4 (g/m)</th>
            <th>Avg (g/m)</th>
            <th>Min (g/m)</th>
            <th>Max (g/m)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div style="text-align:center; margin: 14px 0;">
        <button type="button" id="calcBtn">Calculate Results</button>
        <button type="button" class="btn-save" id="saveBtn" style="display:none;">Save Test</button>
        <button type="button" class="btn-print" id="printCurrentBtn" style="display:none;">Print Current</button>
      </div>

      <div class="metrics" id="metrics" style="display:none;">
        <div class="metric">
          <div class="label">Products Detected</div>
          <div class="value" id="productsDetected">-</div>
        </div>
        <div class="metric" id="metricCardsOOC">
          <div class="label">Cards Out-of-Control (Target ±5%)</div>
          <div class="value" id="oocCardsAll">-</div>
        </div>
        <div class="metric" id="metricCoilersOOC">
          <div class="label">Coiler Readings Out-of-Control (Target ±5%)</div>
          <div class="value" id="oocCoilersAll">-</div>
        </div>
      </div>

      <div style="margin-top:16px;">
        <h2 style="margin-bottom:10px;">Charts (Grouped by Product)</h2>
        <div id="chartsGrid" class="charts-grid"></div>
      </div>
    </div>

    <div class="saved-tests">
      <h2>Saved Tests (Summary by Product Averages)</h2>

      <div class="filter-section">
        <div class="filter-tabs">
          <div class="filter-tab active" onclick="switchFilterTab('date')">Filter by Date</div>
          <div class="filter-tab" onclick="switchFilterTab('cards')">Filter by Cards</div>
          <div class="filter-tab" onclick="switchFilterTab('combined')">Combined Filters</div>
          <div class="filter-tab" onclick="clearFilters()"
            style="margin-left: auto; background: #e74c3c; color: white; border-color: #e74c3c;">Clear Filters</div>
        </div>

        <div id="filterDate" class="filter-content active">
          <div class="filter-row">
            <span class="filter-label">Date Range:</span>
            <select id="dateRangeType" class="filter-input" onchange="onDateRangeTypeChange(); applyFilters();"
              style="min-width: 120px;">
              <option value="">Select Date Range</option>
              <option value="today">Today</option>
              <option value="week">This Week</option>
              <option value="month">This Month</option>
              <option value="custom">Custom Range</option>
            </select>
          </div>
          <div id="customDateRange" class="filter-row" style="display: none;">
            <span class="filter-label">From:</span>
            <input type="date" id="filterDateFrom" class="filter-input" onchange="applyFilters()">
            <span class="filter-label">To:</span>
            <input type="date" id="filterDateTo" class="filter-input" onchange="applyFilters()">
          </div>
          <div class="filter-row">
            <span class="filter-label">Operator:</span>
            <select id="filterOperator" class="filter-input" onchange="applyFilters()" style="min-width: 150px;">
              <option value="">All Operators</option>
            </select>
          </div>
          <div class="filter-row">
            <span class="filter-label">Products:</span>
            <div class="card-selector" id="filterProductSelector">
              <!-- Products will be populated dynamically -->
            </div>
          </div>
          <div class="filter-row">
            <button class="btn-start" onclick="selectAllProducts('filterProductSelector')"
              style="padding: 6px 12px; font-size: 13px;">Select All</button>
            <button class="btn-muted" onclick="deselectAllProducts('filterProductSelector')"
              style="padding: 6px 12px; font-size: 13px;">Deselect All</button>
          </div>
          <div class="filter-buttons">
            <button class="btn-start" onclick="applyFilters()" style="padding: 8px 16px; font-size: 14px;">Apply Date
              Filter</button>
            <button class="btn-print" onclick="viewFilteredResults()" id="viewFilteredBtn"
              style="padding: 8px 16px; font-size: 14px; display: none;">View Filtered Charts</button>
          </div>
        </div>

        <div id="filterCards" class="filter-content">
          <div class="filter-row">
            <span class="filter-label">Card Numbers:</span>
            <div class="card-selector" id="cardSelector">
              <!-- Cards will be populated dynamically -->
            </div>
          </div>
          <div class="filter-row">
            <button class="btn-start" onclick="selectAllCards()" style="padding: 6px 12px; font-size: 13px;">Select
              All</button>
            <button class="btn-muted" onclick="deselectAllCards()" style="padding: 6px 12px; font-size: 13px;">Deselect
              All</button>
          </div>
          <div class="filter-row">
            <span class="filter-label">Products:</span>
            <div class="card-selector" id="cardProductSelector">
              <!-- Products will be populated dynamically -->
            </div>
          </div>
          <div class="filter-row">
            <button class="btn-start" onclick="selectAllProducts('cardProductSelector')"
              style="padding: 6px 12px; font-size: 13px;">Select All</button>
            <button class="btn-muted" onclick="deselectAllProducts('cardProductSelector')"
              style="padding: 6px 12px; font-size: 13px;">Deselect All</button>
          </div>
          <div class="filter-buttons">
            <button class="btn-start" onclick="applyFilters()" style="padding: 8px 16px; font-size: 14px;">Apply Card
              Filter</button>
            <button class="btn-print" onclick="viewFilteredResults()" id="viewFilteredCardsBtn"
              style="padding: 8px 16px; font-size: 14px; display: none;">View Filtered Charts</button>
          </div>
        </div>

        <div id="filterCombined" class="filter-content">
          <div class="filter-row">
            <span class="filter-label">Date Range:</span>
            <select id="combinedDateRangeType" class="filter-input"
              onchange="onCombinedDateRangeTypeChange(); applyFilters();" style="min-width: 120px;">
              <option value="">Select Date Range</option>
              <option value="today">Today</option>
              <option value="week">This Week</option>
              <option value="month">This Month</option>
              <option value="custom">Custom Range</option>
            </select>
          </div>
          <div id="combinedCustomDateRange" class="filter-row" style="display: none;">
            <span class="filter-label">From:</span>
            <input type="date" id="combinedDateFrom" class="filter-input" onchange="applyFilters()">
            <span class="filter-label">To:</span>
            <input type="date" id="combinedDateTo" class="filter-input" onchange="applyFilters()">
          </div>
          <div class="filter-row">
            <span class="filter-label">Operator:</span>
            <select id="combinedOperator" class="filter-input" onchange="applyFilters()" style="min-width: 150px;">
              <option value="">All Operators</option>
            </select>
          </div>
          <div class="filter-row">
            <span class="filter-label">Card Numbers:</span>
            <div class="card-selector" id="combinedCardSelector" style="max-height: 120px;">
              <!-- Cards will be populated dynamically -->
            </div>
          </div>
          <div class="filter-row">
            <span class="filter-label">Products:</span>
            <div class="card-selector" id="combinedProductSelector">
              <!-- Products will be populated dynamically -->
            </div>
          </div>
          <div class="filter-row">
            <button class="btn-start" onclick="selectAllProducts('combinedProductSelector')"
              style="padding: 6px 12px; font-size: 13px;">Select All</button>
            <button class="btn-muted" onclick="deselectAllProducts('combinedProductSelector')"
              style="padding: 6px 12px; font-size: 13px;">Deselect All</button>
          </div>
          <div class="filter-buttons">
            <button class="btn-start" onclick="applyFilters()" style="padding: 8px 16px; font-size: 14px;">Apply
              Combined Filter</button>
            <button class="btn-print" onclick="viewFilteredResults()" id="viewFilteredCombinedBtn"
              style="padding: 8px 16px; font-size: 14px; display: none;">View Filtered Charts</button>
          </div>
        </div>
      </div>

      <div id="filteredResultsPanel"
        style="display: none; margin: 20px 0; padding: 16px; background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <h3 style="margin: 0;">Filtered Results (Grouped by Product)</h3>
          <button class="btn-muted" onclick="closeFilteredResults()"
            style="padding: 6px 12px; font-size: 13px;">Close</button>
        </div>
        <div id="filteredMetrics" class="metrics" style="margin-bottom: 16px;"></div>
        <div id="filteredChartsGrid" class="charts-grid"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; align-items: center;">
          <button class="btn-print" onclick="printFilteredResults()" style="padding: 8px 16px; font-size: 14px;">Print
            Filtered Results</button>
          <span style="color: #666; font-size: 13px;">(Includes charts and sorted data table)</span>
        </div>
      </div>

      <div class="action-row">
        <button class="btn-danger" onclick="deleteSelected()" id="deleteBtn" style="display:none;">Delete
          Selected</button>
        <button class="btn-print" onclick="printSelected()" id="printSelectedBtn" style="display:none;">Print Selected
          (Combined)</button>
        <button class="btn-save" onclick="exportToExcel()" id="exportExcelBtn"
          style="display:inline-block; background:#27ae60;">Export to Excel</button>
        <button class="btn-print" onclick="exportToPDF()" id="exportPDFBtn"
          style="display:inline-block; background:#e67e22;">Export to PDF</button>
      </div>

      <table id="savedTable">
        <thead>
          <tr>
            <th><input type="checkbox" onchange="toggleSelectAll(this)"></th>
            <th>Date & Time</th>
            <th>Report #</th>
            <th>Test Date</th>
            <th>Operator</th>
            <th>Targets Entered</th>
            <th>Product Summary (Avg)</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody id="savedList"></tbody>
      </table>
    </div> <!-- End container -->

    <div id="saveConfirmModal" class="modal-overlay">
      <div class="modal-box">
        <div class="modal-title">Warnings Found</div>
        <div class="modal-message" id="saveConfirmMessage"></div>
        <div class="modal-actions">
          <button type="button" class="btn-modal-cancel" id="btnModalCancel">Go Back</button>
          <button type="button" class="btn-modal-confirm" id="btnModalConfirm">Continue Saving</button>
        </div>
      </div>
    </div>

    <div id="detailsPanel" class="details-panel">
      <div class="details-header">
        <div>
          <div class="details-title" id="detailsTitle">Report Details</div>
          <div class="details-meta" id="detailsMeta"></div>
        </div>
        <div>
          <button class="btn-muted" onclick="closeDetails()">Close</button>
          <button class="btn-print" onclick="printDetails()">Print This Report</button>
        </div>
      </div>

      <div class="details-charts">
        <div id="detailsChartsGrid" class="charts-grid"></div>
      </div>

      <div class="details-table-wrap">
        <h3 style="margin: 6px 0 10px; color:#0f172a;">Single Values (Shown only in Details)</h3>
        <div style="overflow:auto;">
          <table id="detailsTable"></table>
        </div>
      </div>
    </div>
  </div>
  </div>

  <!-- PRINT SECTION -->
  <div id="printSection"
    style="display:none; position:absolute; left:-9999px; top:0; width:100%; background:white; padding:0;">
    <div
      style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #000; padding:2px 0; margin-bottom:3px; box-sizing:border-box;">
      <div style="font-weight:800; font-size:11px; flex-shrink:0;">SPINWISELY</div>
      <div
        style="font-weight:900; font-size:14px; flex:1; text-align:center; padding:0 4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;"
        id="printTitle">Card Sliver Weight Monitoring</div>
      <div id="printDate"
        style="color:#555; font-size:9px; flex-shrink:0; text-align:right; max-width:100px; overflow:hidden; text-overflow:ellipsis;">
      </div>
    </div>

    <div id="printMeta" style="line-height:1.2; margin-bottom: 3px; font-size:9px;"></div>

    <div id="printMetrics" style="display:flex; gap:6px; justify-content:center; margin: 4px 0; flex-wrap:wrap;">
    </div>

    <div id="printChartsContainer"></div>

    <div id="printTablesContainer" style="margin-top: 18px;"></div>
  </div>

  <script>
    // -----------------------------
    // Safety banner
    // -----------------------------
    function showError(msg) {
      const el = document.getElementById('errorBanner');
      el.style.display = 'block';
      el.textContent = msg;
    }

    if (!window.Chart) {
      showError("Chart.js did not load. If your network blocks cdn.jsdelivr.net or you are offline, download Chart.js locally and reference it from a local file.");
    }

    // -----------------------------
    // Custom plugin to draw vertical lines (Mean/LCL/UCL + optional Target)
    // -----------------------------
    const limitLinesPlugin = {
      id: 'limitLinesPlugin',
      afterDatasetsDraw(chart, args, opts) {
        if (!opts || !opts.lines || !opts.lines.length) return;
        const { ctx, chartArea, scales } = chart;
        const xScale = scales.x;
        if (!xScale) return;

        // Detect if this is a print chart (canvas ID starts with "print_")
        const isPrint = chart.canvas.id && chart.canvas.id.startsWith('print_');
        const fontSize = isPrint ? 17 : 12;
        const labelHeight = isPrint ? 22 : 18;
        const labelPad = isPrint ? 6 : 4;
        const printFontFamily = 'Arial, sans-serif';

        ctx.save();
        ctx.lineWidth = isPrint ? 3 : 2;

        // Sort lines to draw Target first (if present), then Mean, then LCL/UCL
        const sortedLines = [...opts.lines].sort((a, b) => {
          const aIsTarget = a.label && a.label.startsWith('Target');
          const bIsTarget = b.label && b.label.startsWith('Target');
          const aIsMean = a.label && a.label.startsWith('Mean');
          const bIsMean = b.label && b.label.startsWith('Mean');
          if (aIsTarget && !bIsTarget) return -1;
          if (!aIsTarget && bIsTarget) return 1;
          if (aIsMean && !bIsMean && !aIsTarget && !bIsTarget) return 1;
          if (!aIsMean && bIsMean && !aIsTarget && !bIsTarget) return -1;
          return 0;
        });

        for (const ln of sortedLines) {
          const xPix = xScale.getPixelForValue(ln.value);
          if (!isFinite(xPix)) continue;

          ctx.strokeStyle = ln.color || '#111827';
          if (ln.dash && ln.dash.length) ctx.setLineDash(ln.dash); else ctx.setLineDash([]);

          ctx.beginPath();
          ctx.moveTo(xPix, chartArea.top);
          ctx.lineTo(xPix, chartArea.bottom);
          ctx.stroke();

          const label = ln.label || '';
          if (label) {
            ctx.setLineDash([]);
            ctx.font = isPrint ? `bold ${fontSize}px ${printFontFamily}` : `${fontSize}px bold Segoe UI, Arial`;

            const w = ctx.measureText(label).width + labelPad * 2;
            const h = labelHeight;
            const bx = Math.min(Math.max(xPix + 6, chartArea.left + 2), chartArea.right - w - 2);

            // Offset Mean label lower than Target to avoid overlap
            const isMean = label.startsWith('Mean');
            const isTarget = label.startsWith('Target');
            const verticalOffset = isMean ? (labelHeight + 2) : 0;
            const by = chartArea.top + 2 + verticalOffset;

            ctx.fillStyle = ln.labelBg || (ln.color || '#111827');
            ctx.fillRect(bx, by, w, h);

            ctx.fillStyle = '#ffffff';
            ctx.fillText(label, bx + labelPad, by + (isPrint ? 16 : 13));
          }
        }
        ctx.restore();
      }
    };

    if (window.Chart && typeof Chart.register === 'function') {
      Chart.register(limitLinesPlugin);
    }

    // -----------------------------
    // Constants/state
    // -----------------------------
    const TOTAL_CARDS = 15;
    const COILERS_PER_CARD = 4;
    const PRODUCT_OPTIONS_BASE = ["Q tip", "Triple", "Organic", "Special"];
    const PRODUCT_DEFAULT = "";

    function getProductOptions() {
      const customName = document.getElementById('t_custom_name')?.value?.trim();
      const customTarget = parseFloat(document.getElementById('t_custom')?.value);
      const options = [...PRODUCT_OPTIONS_BASE];
      if (customName && isFinite(customTarget) && customTarget > 0) {
        options.push(customName);
      }
      return options;
    }

    function getProductColorClass(productName) {
      const name = (productName || '').toLowerCase().trim();
      if (name === 'q tip' || name === 'qtip') return 'qtip';
      if (name === 'triple') return 'triple';
      if (name === 'organic') return 'organic';
      if (name === 'special') return 'special';
      return 'custom';
    }

    let cardRows = [];
    let currentTest = null;
    let detailsTest = null;
    let hasUnsavedData = false;
    let isDataCalculated = false; // Track if data has been calculated (needs recalculation if changed)
    let isTestSaved = false; // Track if current test has been saved

    const chartInstances = new Map();
    const detailsChartInstances = new Map();
    const printChartInstances = new Map();

    // RS-232 Scale integration
    let scalePort = null;
    let scaleReader = null;
    let scaleConnected = false;
    let currentScaleValue = null;

    // -----------------------------
    // Storage
    // -----------------------------
    function getReportCounter() {
      try {
        const stored = localStorage.getItem('sliverReportCounter');
        if (stored) {
          const parsed = parseInt(stored, 10);
          if (!isNaN(parsed) && parsed > 1000) return parsed;
        }
      } catch (_) { }
      return 1000;
    }
    function setReportCounter(value) {
      try { localStorage.setItem('sliverReportCounter', String(value)); } catch (_) { }
    }

    function getSavedTests() {
      try {
        const stored = localStorage.getItem('sliverTests_v6');
        if (stored) {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) return parsed;
        }
      } catch (_) {
        try { localStorage.removeItem('sliverTests_v6'); } catch (__) { }
      }
      return [];
    }
    function setSavedTests(tests) {
      try {
        localStorage.setItem('sliverTests_v6', JSON.stringify(tests));
      } catch (e) {
        throw e; // Bubble up error to saveTest
      }
    }

    // -----------------------------
    // Persistent Product Configs & Card Logic
    // -----------------------------
    // IDs of inputs to persist
    const PRODUCT_INPUT_IDS = [
      't_qtip', 'r_qtip', 'c_qtip',
      't_triple', 'r_triple', 'c_triple',
      't_organic', 'r_organic', 'c_organic',
      't_special', 'r_special', 'c_special',
      't_custom_name', 't_custom', 'r_custom', 'c_custom'
    ];

    function saveProductConfigs() {
      const data = {};
      PRODUCT_INPUT_IDS.forEach(id => {
        const el = document.getElementById(id);
        if (el) data[id] = el.value;
      });
      try {
        localStorage.setItem('sliverProductConfigs', JSON.stringify(data));
      } catch (_) { }
    }

    function loadProductConfigs() {
      try {
        const stored = localStorage.getItem('sliverProductConfigs');
        if (stored) {
          const data = JSON.parse(stored);
          PRODUCT_INPUT_IDS.forEach(id => {
            if (data[id] !== undefined) {
              const el = document.getElementById(id);
              if (el) el.value = data[id];
            }
          });
        }
      } catch (_) { }
    }

    // Parses "1-3, 5, 8-10" into [1, 2, 3, 5, 8, 9, 10]
    function parseCardRange(str) {
      const cards = new Set();
      if (!str) return [];

      // Split by comma
      const parts = str.split(',');
      for (const part of parts) {
        const p = part.trim();
        if (!p) continue;

        if (p.includes('-')) {
          const [startStr, endStr] = p.split('-');
          const s = parseInt(startStr, 10);
          const e = parseInt(endStr, 10);
          if (!isNaN(s) && !isNaN(e)) {
            const low = Math.min(s, e);
            const high = Math.max(s, e);
            for (let i = low; i <= high; i++) {
              if (i >= 1 && i <= TOTAL_CARDS) cards.add(i);
            }
          }
        } else {
          const val = parseInt(p, 10);
          if (!isNaN(val) && val >= 1 && val <= TOTAL_CARDS) {
            cards.add(val);
          }
        }
      }
      return Array.from(cards).sort((a, b) => a - b);
    }

    // Compile assignments: index 1..15 => { productName, target, range }
    function getCardAssignments() {
      const assignments = new Array(TOTAL_CARDS + 1).fill(null);

      // Helper to process product block
      function processProduct(nameId, targetId, rangeId, cardsId, defaultName) {
        const nameEl = document.getElementById(nameId);
        const targetEl = document.getElementById(targetId);
        const rangeEl = document.getElementById(rangeId);
        const cardsEl = document.getElementById(cardsId);

        const name = (nameId && nameEl) ? nameEl.value.trim() : defaultName;
        const target = targetEl ? targetEl.value : '';
        const range = rangeEl ? rangeEl.value : '5.0';
        const cardStr = cardsEl ? cardsEl.value : '';

        if (cardStr) {
          const cIds = parseCardRange(cardStr);
          cIds.forEach(cId => {
            assignments[cId] = { productName: name || defaultName, target, range };
          });
        }
      }

      processProduct(null, 't_qtip', 'r_qtip', 'c_qtip', 'Q tip');
      processProduct(null, 't_triple', 'r_triple', 'c_triple', 'Triple');
      processProduct(null, 't_organic', 'r_organic', 'c_organic', 'Organic');
      processProduct(null, 't_special', 'r_special', 'c_special', 'Special');
      processProduct('t_custom_name', 't_custom', 'r_custom', 'c_custom', 'Custom Product');

      return assignments;
    }

    // -----------------------------
    // Operator Persistence
    // -----------------------------
    function loadOperatorHistory() {
      try {
        const history = JSON.parse(localStorage.getItem('sliverOperatorHistory') || '[]');
        const lastOp = localStorage.getItem('sliverLastOperator');

        const dataList = document.getElementById('operatorList');
        if (dataList) {
          dataList.innerHTML = history.map(name => `<option value="${escapeHtml(name)}">`).join('');
        }

        if (lastOp) {
          document.getElementById('operatorName').value = lastOp;
        }
      } catch (_) { }
    }

    function saveOperator(name) {
      if (!name) return;
      try {
        localStorage.setItem('sliverLastOperator', name);

        let history = JSON.parse(localStorage.getItem('sliverOperatorHistory') || '[]');
        if (!history.includes(name)) {
          history.push(name);
          // keep history reasonable size? e.g. 50
          if (history.length > 50) history.shift();
          localStorage.setItem('sliverOperatorHistory', JSON.stringify(history));

          // update datalist immediately
          const dataList = document.getElementById('operatorList');
          if (dataList) {
            dataList.innerHTML = history.map(n => `<option value="${escapeHtml(n)}">`).join('');
          }
        }
      } catch (_) { }
    }

    // -----------------------------
    // Init
    // -----------------------------
    // Initialize
    window.onload = function () {
      try {
        loadProductConfigs(); // Load saved targets & card ranges
        loadOperatorHistory(); // Load operator defaults

        // Attach button listeners
        const calcBtn = document.getElementById('calcBtn');
        if (calcBtn) calcBtn.addEventListener('click', calculateResults);

        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) saveBtn.addEventListener('click', saveTest);

        const printCurrentBtn = document.getElementById('printCurrentBtn');
        if (printCurrentBtn) printCurrentBtn.addEventListener('click', printCurrent);

        // Modal Listeners
        const btnModalCancel = document.getElementById('btnModalCancel');
        const btnModalConfirm = document.getElementById('btnModalConfirm');
        if (btnModalCancel) {
          btnModalCancel.addEventListener('click', function () {
            document.getElementById('saveConfirmModal').style.display = 'none';
            // Scroll to defect if needed
            if (currentTest && currentTest.outOfControlCardNos && currentTest.outOfControlCardNos.length > 0) {
              const firstDefectiveCard = currentTest.outOfControlCardNos[0];
              const cardRow = document.getElementById(`cardRow_${firstDefectiveCard}`);
              if (cardRow) {
                cardRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                cardRow.style.transition = 'background-color 0.3s';
                cardRow.style.backgroundColor = '#fff3cd';
                setTimeout(() => { cardRow.style.backgroundColor = ''; }, 2000);
              }
            }
          });
        }
        if (btnModalConfirm) {
          btnModalConfirm.addEventListener('click', function () {
            document.getElementById('saveConfirmModal').style.display = 'none';
            finalizeSave();
          });
        }

        // Attach change listeners to auto-save
        PRODUCT_INPUT_IDS.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.addEventListener('change', saveProductConfigs);
        });

        let reportCounter = getReportCounter();
        reportCounter++;
        setReportCounter(reportCounter);
        document.getElementById('reportNumber').value = reportCounter;

        const today = new Date();
        const options = { day: '2-digit', month: 'short', year: 'numeric' };
        document.getElementById('currentDate').textContent = today.toLocaleDateString('en-GB', options);
        document.getElementById('printDate').textContent = today.toLocaleDateString('en-GB', options);

        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        const todayStr = `${yyyy}-${mm}-${dd}`;

        const minDate = new Date(today); minDate.setDate(today.getDate() - 7);
        const maxDate = new Date(today); maxDate.setDate(today.getDate() + 7);

        const dateInput = document.getElementById('testDate');
        dateInput.value = todayStr;
        dateInput.min = minDate.toISOString().split('T')[0];
        dateInput.max = maxDate.toISOString().split('T')[0];

        loadSavedTests();
        initializeFilters();

        // Check for scale support on page load
        if (!navigator.serial) {
          // Web Serial API not available - will show message when test section opens
        }

        // Add warning when trying to close tab with unsaved data
        window.addEventListener('beforeunload', function (e) {
          // Check if there's any entered data (at least one coiler value entered)
          const hasData = cardRows && cardRows.length > 0 &&
            cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));

          if (hasData) {
            // Modern browsers require setting returnValue and returning a value
            e.preventDefault();
            e.returnValue = 'Data not saved, do you wish to close the tab?';
            return e.returnValue;
          }
        });
      } catch (e) {
        showError("Initialization failed: " + (e && e.message ? e.message : String(e)));
      }
    };

    // -----------------------------
    // Targets (top inputs)
    // -----------------------------
    function getTargets() {
      const map = {
        "Q tip": parseFloat(document.getElementById('t_qtip').value),
        "Triple": parseFloat(document.getElementById('t_triple').value),
        "Organic": parseFloat(document.getElementById('t_organic').value),
        "Special": parseFloat(document.getElementById('t_special').value)
      };
      const out = {};
      for (const k of Object.keys(map)) {
        const v = map[k];
        out[k] = (isFinite(v) && v > 0) ? v : null;
      }
      // Add custom product if name and target are provided
      const customName = document.getElementById('t_custom_name')?.value?.trim();
      const customTarget = parseFloat(document.getElementById('t_custom')?.value);
      if (customName && isFinite(customTarget) && customTarget > 0) {
        out[customName] = customTarget;
      }
      return out;
    }

    function getAcceptableRanges() {
      const ranges = {
        "Q tip": parseFloat(document.getElementById('r_qtip')?.value || '5.0'),
        "Triple": parseFloat(document.getElementById('r_triple')?.value || '5.0'),
        "Organic": parseFloat(document.getElementById('r_organic')?.value || '5.0'),
        "Special": parseFloat(document.getElementById('r_special')?.value || '5.0')
      };
      // Validate ranges
      for (const k of Object.keys(ranges)) {
        const v = ranges[k];
        if (!isFinite(v) || v < 0.5 || v > 20) ranges[k] = 5.0;
      }
      // Add custom product range if custom product exists
      const customName = document.getElementById('t_custom_name')?.value?.trim();
      const customTarget = parseFloat(document.getElementById('t_custom')?.value);
      if (customName && isFinite(customTarget) && customTarget > 0) {
        const customRange = parseFloat(document.getElementById('r_custom')?.value || '5.0');
        ranges[customName] = (isFinite(customRange) && customRange >= 0.5 && customRange <= 20) ? customRange : 5.0;
      }
      return ranges;
    }

    function getAcceptableRange(productName) {
      const ranges = getAcceptableRanges();
      return ranges[productName] || 5.0;
    }

    function formatTargets(targets) {
      // Show all products with targets, with 0.00 for products without target values
      const baseProducts = PRODUCT_OPTIONS_BASE;
      const parts = baseProducts.map(p => {
        const value = (targets && targets[p] !== null && targets[p] !== undefined && isFinite(targets[p]) && targets[p] > 0)
          ? Number(targets[p]).toFixed(2)
          : '0.00';
        return `${p}: ${value}`;
      });
      // Add custom product if it exists in targets
      if (targets) {
        for (const key of Object.keys(targets)) {
          if (!baseProducts.includes(key) && targets[key] !== null && targets[key] > 0) {
            parts.push(`${key}: ${Number(targets[key]).toFixed(2)}`);
          }
        }
      }
      if (!parts.length) return '-';
      return parts.join(' | ');
    }

    // -----------------------------
    // Validation / Start
    // -----------------------------
    function validateInputs() {
      const operatorName = document.getElementById('operatorName').value.trim();
      const testDate = document.getElementById('testDate').value;
      if (!operatorName || !testDate) {
        alert('Please fill in Operator Name and Test Date.');
        return false;
      }
      saveOperator(operatorName); // Save on successful validation
      return true;
    }

    function validateCardAssignments() {
      const allCards = [];
      const overlaps = new Set();

      const productInputs = [
        { id: 'c_qtip', name: 'Q tip' },
        { id: 'c_triple', name: 'Triple' },
        { id: 'c_organic', name: 'Organic' },
        { id: 'c_special', name: 'Special' },
        { id: 'c_custom', name: 'Custom Product' }
      ];

      productInputs.forEach(p => {
        const el = document.getElementById(p.id);
        if (el && el.value.trim()) {
          const cards = parseCardRange(el.value);
          cards.forEach(c => {
            if (allCards.includes(c)) {
              overlaps.add(c);
            }
            allCards.push(c);
          });
        }
      });

      if (overlaps.size > 0) {
        const sortedOverlaps = Array.from(overlaps).sort((a, b) => a - b);
        alert(`Error: Card(s) ${sortedOverlaps.join(', ')} are assigned to multiple products. Please correct assignments.`);
        return false;
      }
      return true;
    }

    function validateAndStart() {
      if (!validateInputs()) return;
      if (!validateCardAssignments()) return;
      startEntry();
    }

    function validateAndSimulate() {
      if (!validateInputs()) return;
      if (!validateCardAssignments()) return;

      // Identify assigned products
      const assignments = getCardAssignments();
      const assignedProductNames = new Set(assignments.filter(a => a).map(a => a.productName));

      // Map product names to their input IDs for checking/setting defaults
      const productMap = {
        "Q tip": 't_qtip',
        "Triple": 't_triple',
        "Organic": 't_organic',
        "Special": 't_special',
        "Custom Product": 't_custom'
      };

      // Only fill targets for assigned products if they are empty
      assignedProductNames.forEach(pName => {
        const tId = productMap[pName];
        // Custom product name might vary, but key in map is fixed base or handled? 
        // Actually custom product logic logic:
        if (pName === 'Custom Product' || (pName && !productMap[pName])) {
          // It's custom, check t_custom
          if (!document.getElementById('t_custom').value) {
            document.getElementById('t_custom').value = (4.50 + Math.random() * 0.3).toFixed(2);
          }
        } else if (tId) {
          if (!document.getElementById(tId).value) {
            document.getElementById(tId).value = (4.50 + Math.random() * 0.3).toFixed(2);
          }
        }
      });

      startEntry();
      simulateData();
      calculateResults();
    }

    function startNewTest() {
      // Check if there's any unsaved data
      const hasData = cardRows && cardRows.length > 0 &&
        cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));

      if (hasData || hasUnsavedData) {
        const confirmMessage = 'Warning: All unsaved data will be lost.\n\nDo you want to start a new test?';
        if (!confirm(confirmMessage)) {
          return; // User cancelled
        }
      }

      // Reset all form fields
      // Reset targets
      document.getElementById('t_qtip').value = '';
      document.getElementById('t_triple').value = '';
      document.getElementById('t_organic').value = '';
      document.getElementById('t_special').value = '';
      document.getElementById('t_custom').value = '';
      document.getElementById('t_custom_name').value = '';

      // Reset acceptable ranges to default (5.0)
      document.getElementById('r_qtip').value = '5.0';
      document.getElementById('r_triple').value = '5.0';
      document.getElementById('r_organic').value = '5.0';
      document.getElementById('r_special').value = '5.0';
      document.getElementById('r_custom').value = '5.0';

      // Reset operator name (do NOT reset if we want persistent default, but "Start New Test" implies fresh canvas)
      // Requirement: "last entered operator name should come as default when the page loaded next time"
      // Usually "Start New Test" clears everything for a fresh start. 
      // If user wants to keep operator, they can select from dropdown.
      // Let's clear it, but the autofill happens on page load.
      document.getElementById('operatorName').value = '';

      // Reset test date to today
      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth() + 1).padStart(2, '0');
      const dd = String(today.getDate()).padStart(2, '0');
      const todayStr = `${yyyy}-${mm}-${dd}`;
      document.getElementById('testDate').value = todayStr;

      // Get next report number
      let reportCounter = getReportCounter();
      reportCounter++;
      setReportCounter(reportCounter);
      document.getElementById('reportNumber').value = reportCounter;

      // Hide test section
      document.getElementById('testSection').style.display = 'none';

      // Reset all state variables
      cardRows = [];
      currentTest = null;
      hasUnsavedData = false;
      isDataCalculated = false;
      isTestSaved = false;

      // Reset buttons
      document.getElementById('saveBtn').style.display = 'none';
      document.getElementById('printCurrentBtn').style.display = 'none';

      // Clear charts
      destroyChartMap(chartInstances, 'chartsGrid');

      // Hide metrics
      document.getElementById('metrics').style.display = 'none';

      // Clear error banner
      document.getElementById('errorBanner').style.display = 'none';
    }

    function startEntry() {
      // Get assignments from inputs
      const assignments = getCardAssignments();

      cardRows = Array.from({ length: TOTAL_CARDS }, (_, i) => {
        const cId = i + 1;
        const assign = assignments[cId];
        return {
          cardNo: cId,
          product: assign ? assign.productName : PRODUCT_DEFAULT,
          coilers: Array(COILERS_PER_CARD).fill(null),
          avg: null
        };
      });

      // Reset unsaved data flag when starting new entry
      hasUnsavedData = false;

      const tbody = document.querySelector('#sliverTable tbody');
      tbody.innerHTML = '';

      for (let i = 0; i < TOTAL_CARDS; i++) {
        const cardNo = i + 1;
        const tr = document.createElement('tr');
        tr.id = `cardRow_${cardNo}`;

        const assign = assignments[cardNo];
        const assignedProduct = assign ? assign.productName : '';

        // Set row color if assigned
        let rowClass = '';
        if (assignedProduct) {
          rowClass = 'row-' + getProductColorClass(assignedProduct);
          tr.className = rowClass;
        }

        // Build options with selected
        const optionsHtml = getProductOptions().map(p => {
          const selected = (p === assignedProduct) ? 'selected' : '';
          return `<option value="${escapeHtml(p)}" ${selected}>${escapeHtml(p)}</option>`;
        }).join('');

        const defaultSelected = assignedProduct ? '' : 'selected';

        // Target display
        let targetDisplay = '-';
        let targetStyle = 'font-weight: 600; color: #2c3e50;';
        if (assign && assign.target) {
          const tVal = parseFloat(assign.target);
          if (isFinite(tVal) && tVal > 0) {
            targetDisplay = tVal.toFixed(2);
          } else {
            targetDisplay = '-';
            targetStyle = 'color: #999;';
          }
        } else {
          targetStyle = 'color: #999;';
        }

        tr.innerHTML = `
        <td><strong>${cardNo}</strong></td>
        <td>
          <select class="card-input" style="padding:8px 10px; font-size:14px;"
            onchange="updateProduct(${cardNo}, this.value)">
            <option value="" ${defaultSelected}>-- Select --</option>
            ${optionsHtml}
          </select>
        </td>
        <td id="targetCell_${cardNo}" style="${targetStyle}">${targetDisplay}</td>
        ${Array.from({ length: COILERS_PER_CARD }, (_, c) => `
          <td><input type="number" step="0.001" style="width:120px;" id="coiler_${cardNo}_${c + 1}"
              onchange="updateCoiler(${cardNo}, ${c + 1}, this.value)"
              onfocus="handleCoilerFocus(${cardNo}, ${c + 1})"></td>
        `).join('')}
        <td class="avg-cell" id="avgCell_${cardNo}">-</td>
        <td id="minCell_${cardNo}">-</td>
        <td id="maxCell_${cardNo}">-</td>
      `;
        tbody.appendChild(tr);
      }

      document.getElementById('testSection').style.display = 'block';

      // Show Save button but disabled initially (Print Current only shown after saving)
      document.getElementById('saveBtn').style.display = 'inline-block';
      document.getElementById('printCurrentBtn').style.display = 'none';
      disableSavePrintButtons();

      document.getElementById('metrics').style.display = 'none';

      destroyChartMap(chartInstances, 'chartsGrid');
      currentTest = null;
      isDataCalculated = false;
      isTestSaved = false;

      // Check for scale support - show message if not available
      if (!navigator.serial) {
        showScaleStatus('Web Serial API not supported. Please enter values manually.', 'info');
      }
    }

    function updateProduct(cardNo, product) {
      cardRows[cardNo - 1].product = product;
      const tr = document.getElementById(`cardRow_${cardNo}`);

      // Remove all product color classes
      if (tr) {
        tr.classList.remove('row-qtip', 'row-triple', 'row-organic', 'row-special', 'row-custom');
        // Add appropriate color class based on product
        if (product) {
          const colorClass = getProductColorClass(product);
          tr.classList.add(`row-${colorClass}`);
        }
      }

      // Update target value display
      const targets = getTargets();
      const targetCell = document.getElementById(`targetCell_${cardNo}`);
      if (targetCell) {
        if (product && targets[product] !== null && targets[product] > 0) {
          targetCell.textContent = targets[product].toFixed(2);
          targetCell.style.color = '#2c3e50';
        } else {
          targetCell.textContent = '-';
          targetCell.style.color = '#999';
        }
      }

      // If data was previously calculated, disable buttons (need to recalculate)
      if (isDataCalculated) {
        isDataCalculated = false;
        disableSavePrintButtons();
        // If test was saved, show Save button again (but disabled)
        if (isTestSaved) {
          document.getElementById('saveBtn').style.display = 'inline-block';
          document.getElementById('printCurrentBtn').style.display = 'inline-block';
        }
      }
    }

    function updateCoiler(cardNo, coilerNo, value) {
      const row = cardRows[cardNo - 1];
      const v = (value === '' || value === null) ? null : parseFloat(value);
      row.coilers[coilerNo - 1] = isFinite(v) ? v : null;

      const vals = row.coilers.filter(x => x !== null);
      row.avg = vals.length ? (vals.reduce((a, b) => a + b, 0) / vals.length) : null;

      // Calculate min and max
      const minVal = vals.length > 0 ? Math.min(...vals) : null;
      const maxVal = vals.length > 0 ? Math.max(...vals) : null;

      // Update display
      document.getElementById(`avgCell_${cardNo}`).textContent = row.avg === null ? '-' : row.avg.toFixed(2);
      document.getElementById(`minCell_${cardNo}`).textContent = minVal === null ? '-' : minVal.toFixed(3);
      document.getElementById(`maxCell_${cardNo}`).textContent = maxVal === null ? '-' : maxVal.toFixed(3);

      // Mark as having unsaved data if any value is entered
      // Also check if all data has been cleared
      const hasAnyData = cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));
      hasUnsavedData = hasAnyData;

      // If data was previously calculated, disable buttons (need to recalculate)
      if (isDataCalculated) {
        isDataCalculated = false;
        disableSavePrintButtons();
        // If test was saved, show Save button again (but disabled)
        if (isTestSaved) {
          document.getElementById('saveBtn').style.display = 'inline-block';
          document.getElementById('printCurrentBtn').style.display = 'inline-block';
        }
      }

      // Auto-update charts if there's data
      autoUpdateCharts();
    }

    // Enable Save and Print buttons
    function enableSavePrintButtons() {
      const saveBtn = document.getElementById('saveBtn');
      const printBtn = document.getElementById('printCurrentBtn');
      if (saveBtn) {
        saveBtn.disabled = false;
      }
      if (printBtn) {
        printBtn.disabled = false;
      }
    }

    // Disable Save and Print buttons (light color, not enabled)
    function disableSavePrintButtons() {
      const saveBtn = document.getElementById('saveBtn');
      const printBtn = document.getElementById('printCurrentBtn');
      if (saveBtn) {
        saveBtn.disabled = true;
      }
      if (printBtn) {
        printBtn.disabled = true;
      }
    }

    // Auto-update charts incrementally as data is entered
    function autoUpdateCharts() {
      try {
        const anyValues = cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));
        if (!anyValues) {
          // Hide metrics if no data
          const metricsContainer = document.getElementById('metrics');
          if (metricsContainer) metricsContainer.style.display = 'none';
          return;
        }

        const targets = getTargets();
        const acceptableRanges = getAcceptableRanges();
        const groups = groupData(cardRows);
        const productsPresent = Object.keys(groups)
          .filter(p => groups[p].allValues.length > 0)
          .sort((a, b) => a.localeCompare(b));

        if (!productsPresent.length) {
          // Hide metrics if no product groups
          const metricsContainer = document.getElementById('metrics');
          if (metricsContainer) metricsContainer.style.display = 'none';
          return;
        }

        // Update charts (without full validation - allows incremental updates)
        renderGroupedCharts(groups, productsPresent, 'chartsGrid', chartInstances, targets, acceptableRanges);

        // Update metrics (without full validation - allows incremental updates)
        autoUpdateMetrics(groups, productsPresent, targets, acceptableRanges);
      } catch (e) {
        // Silently fail on auto-update - don't interrupt user input
        console.error('Auto-update charts error:', e);
      }
    }

    // Auto-update metrics incrementally as data is entered
    function autoUpdateMetrics(groups, productsPresent, targets, acceptableRanges) {
      try {
        const metricsContainer = document.getElementById('metrics');
        if (!metricsContainer) return;

        // Clear row highlighting
        for (const r of cardRows) {
          const tr = document.getElementById(`cardRow_${r.cardNo}`);
          if (tr) tr.classList.remove('out-of-control');
        }

        let oocCardsAll = 0;
        let oocCoilersAll = 0;
        const productStats = {};

        // OOC computations are per product, using per-product ranges
        for (const p of productsPresent) {
          const g = groups[p];
          const productRange = acceptableRanges[p] || 5.0;

          // Chart-level stats (mean-based)
          const meanCard = meanOf(g.cardAvgs);
          const limCardMean = limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(g.allValues);
          const limAllMean = limitsFromMean(meanAll, productRange);

          // OOC limits (target-based when available, otherwise mean-based)
          const tgt = targets[p];
          const limTarget = (tgt !== null && isFinite(tgt) && tgt > 0) ? limitsFromTarget(tgt, productRange) : null;
          const limCardOOC = limTarget || limCardMean;
          const limCoilerOOC = limTarget || limAllMean;

          let oocCards = 0;
          let oocCoilers = 0;

          for (const r of cardRows) {
            if ((r.product || '').trim() !== p) continue;

            // Card average OOC
            if (r.avg !== null && isFinite(r.avg)) {
              if (!withinLimits(Number(r.avg), limCardOOC)) {
                oocCards++;
                oocCardsAll++;
                const tr = document.getElementById(`cardRow_${r.cardNo}`);
                if (tr) tr.classList.add('out-of-control');
              }
            }

            // Individual coilers OOC
            for (const v of (r.coilers || [])) {
              if (v === null || !isFinite(v)) continue;
              if (!withinLimits(Number(v), limCoilerOOC)) {
                oocCoilers++;
                oocCoilersAll++;
              }
            }
          }

          // Calculate min/max for card averages and coiler readings
          const cardAvgMin = g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs) : null;
          const cardAvgMax = g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs) : null;
          const coilerMin = g.allValues.length > 0 ? Math.min(...g.allValues) : null;
          const coilerMax = g.allValues.length > 0 ? Math.max(...g.allValues) : null;

          productStats[p] = {
            countCards: g.cardAvgs.length,
            countCoilerValues: g.allValues.length,
            cardAvgMean: meanCard,
            cardAvgLCL: limCardMean.lcl,
            cardAvgUCL: limCardMean.ucl,
            cardAvgMin,
            cardAvgMax,
            allMean: meanAll,
            allLCL: limAllMean.lcl,
            allUCL: limAllMean.ucl,
            coilerMin,
            coilerMax,
            target: tgt,
            targetLCL: limCardOOC.lcl,
            targetUCL: limCardOOC.ucl,
            oocCards,
            oocCoilers
          };
        }

        // Build metrics HTML: first box for products, then per-product boxes
        let metricsHTML = `
        <div class="metric">
          <div class="label">Products Detected</div>
          <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
        </div>
      `;

        // Calculate total cards and coilers per product
        const totalCardsPerProduct = {};
        const totalCoilersPerProduct = {};
        for (const p of productsPresent) {
          totalCardsPerProduct[p] = groups[p].cardAvgs.length;
          totalCoilersPerProduct[p] = groups[p].allValues.length;
        }

        // Add per-product metrics (2 boxes per product: cards and coilers)
        for (const p of productsPresent) {
          const productRange = acceptableRanges[p] || 5.0;
          const rangeStr = productRange.toFixed(1);
          const totalCards = totalCardsPerProduct[p];
          const totalCoilers = totalCoilersPerProduct[p];
          const oocCards = productStats[p].oocCards || 0;
          const oocCoilers = productStats[p].oocCoilers || 0;
          const cardsBg = oocCards > 0 ? '#e74c3c' : '#3498db';
          const coilersBg = oocCoilers > 0 ? '#e74c3c' : '#3498db';

          const cardMin = productStats[p].cardAvgMin !== null ? productStats[p].cardAvgMin.toFixed(2) : '-';
          const cardMax = productStats[p].cardAvgMax !== null ? productStats[p].cardAvgMax.toFixed(2) : '-';
          const coilerMinVal = productStats[p].coilerMin !== null ? productStats[p].coilerMin.toFixed(3) : '-';
          const coilerMaxVal = productStats[p].coilerMax !== null ? productStats[p].coilerMax.toFixed(3) : '-';

          metricsHTML += `
          <div class="metric" style="background: ${cardsBg};">
            <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCards} out of ${totalCards}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
          </div>
          <div class="metric" style="background: ${coilersBg};">
            <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCoilers} out of ${totalCoilers}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${coilerMinVal} | Max: ${coilerMaxVal}</div>
          </div>
        `;
        }

        metricsContainer.innerHTML = metricsHTML;
        metricsContainer.style.display = 'flex';
      } catch (e) {
        // Silently fail on auto-update - don't interrupt user input
        console.error('Auto-update metrics error:', e);
      }
    }

    function simulateData() {
      // Get existing target values (infeed values) or use defaults
      const targets = getTargets();
      const defaultBase = 4.6;

      const inputs = document.querySelectorAll('#sliverTable tbody input[type="number"]');

      // Iterate through existing card rows set up by startEntry
      for (let i = 0; i < TOTAL_CARDS; i++) {
        const row = cardRows[i];
        const product = row.product; // Already set by startEntry based on assignments

        // If no product assigned to this card, skip
        if (!product) continue;

        // Get target for this product
        const tVal = targets[product];
        const targetValue = (tVal !== null && isFinite(tVal) && tVal > 0) ? tVal : defaultBase;

        // Simulate values
        const base = targetValue;
        const cardBias = (Math.random() - 0.5) * (base * 0.03);

        for (let c = 0; c < COILERS_PER_CARD; c++) {
          const v = base + cardBias + (Math.random() - 0.5) * (base * 0.02);
          updateCoiler(i + 1, c + 1, v.toFixed(3));

          // Update input field if it exists
          if (inputs[i * COILERS_PER_CARD + c]) {
            inputs[i * COILERS_PER_CARD + c].value = v.toFixed(3);
          }
        }
      }
    }

    // -----------------------------
    // Math helpers
    // -----------------------------
    function meanOf(arr) { return arr.reduce((a, b) => a + b, 0) / arr.length; }
    function sampleStd(arr, mean) {
      if (arr.length < 2) return 0;
      const v = arr.reduce((s, x) => s + (x - mean) ** 2, 0) / (arr.length - 1);
      return Math.sqrt(v);
    }
    function limitsFromMean(mean, rangePct) {
      const range = rangePct !== undefined ? rangePct : getAcceptableRange();
      const factor = range / 100;
      return { lcl: mean * (1 - factor), ucl: mean * (1 + factor) };
    }
    function limitsFromTarget(target, rangePct) {
      const range = rangePct !== undefined ? rangePct : getAcceptableRange();
      const factor = range / 100;
      return { lcl: target * (1 - factor), ucl: target * (1 + factor) };
    }
    function withinLimits(v, lim) { return v >= lim.lcl && v <= lim.ucl; }

    function groupData(rows) {
      const groups = {};
      for (const r of rows) {
        const p = (r.product || '').trim();
        if (!p) continue;
        if (!groups[p]) groups[p] = { cardAvgs: [], allValues: [], cardNos: [] };

        if (r.avg !== null && isFinite(r.avg)) {
          groups[p].cardAvgs.push(Number(r.avg));
          groups[p].cardNos.push(r.cardNo);
        }
        for (const v of (r.coilers || [])) {
          if (v !== null && isFinite(v)) groups[p].allValues.push(Number(v));
        }
      }
      return groups;
    }

    // -----------------------------
    // Validation rules
    // -----------------------------
    function validatePerCardRulesOrAlert(rows) {
      const missingProductCards = [];
      const partialCoilerCards = [];

      for (const r of rows) {
        const enteredCount = (r.coilers || []).filter(v => v !== null && isFinite(v)).length;
        if (enteredCount === 0) continue;

        if (!(r.product || '').trim()) missingProductCards.push(r.cardNo);
        if (enteredCount !== COILERS_PER_CARD) partialCoilerCards.push(r.cardNo);
      }

      if (missingProductCards.length || partialCoilerCards.length) {
        let msg = '';
        if (missingProductCards.length) msg += `Please select Product for Card(s): ${missingProductCards.join(', ')}.\n`;
        if (partialCoilerCards.length) msg += `Please enter all 4 coiler values for Card(s): ${partialCoilerCards.join(', ')}.\n`;
        alert(msg.trim());
        return false;
      }
      return true;
    }

    // Require target for any product that has at least one entered card (so OOC can be target-based)
    function validateTargetsForUsedProductsOrAlert(rows, targets) {
      const usedProducts = new Set();
      for (const r of rows) {
        const enteredCount = (r.coilers || []).filter(v => v !== null && isFinite(v)).length;
        if (enteredCount > 0) usedProducts.add((r.product || '').trim());
      }

      const missingTargets = [];
      for (const p of usedProducts) {
        if (!p) continue;
        if (!(targets[p] !== null && isFinite(targets[p]) && targets[p] > 0)) {
          missingTargets.push(p);
        }
      }

      if (missingTargets.length) {
        alert(`Please enter Target (g/m) for product(s): ${missingTargets.join(', ')}.\nTargets are required for Out-of-Control checks.`);
        return false;
      }
      return true;
    }

    // -----------------------------
    // Charting (Histogram + Normal curve + Mean/LCL/UCL + Target line)
    // -----------------------------
    function buildHistogram(data) {
      const n = data.length;
      const bins = Math.min(14, Math.max(6, Math.round(Math.sqrt(n) * 1.8)));
      const min = Math.min(...data);
      const max = Math.max(...data);
      const range = (max - min) || 1;
      const binSize = range / bins;

      const counts = new Array(bins).fill(0);
      for (const v of data) {
        const idx = Math.min(Math.floor((v - min) / binSize), bins - 1);
        counts[idx]++;
      }

      const centers = counts.map((_, i) => min + (i + 0.5) * binSize);
      return { centers, counts, min, max, binSize };
    }

    function buildNormalCurvePoints(min, max, mean, sigma, nPoints, scale) {
      const xs = Array.from({ length: nPoints }, (_, i) => min + i * (max - min) / (nPoints - 1));
      return xs.map(x => {
        const z = (x - mean) / sigma;
        const pdf = Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI);
        return { x, y: pdf * scale };
      });
    }

    function plotDistribution(canvasId, data, mean, lcl, ucl, titleText, chartMap, targetValueOrNull) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      // Detect if this is a print chart
      const isPrint = canvasId && canvasId.startsWith('print_');

      const { centers, counts, min, max, binSize } = buildHistogram(data);
      const sigma = sampleStd(data, mean) || 1e-9;
      const scale = data.length * binSize;
      const curve = buildNormalCurvePoints(min, max, mean, sigma, 160, scale);

      const bars = centers.map((x, i) => ({ x, y: counts[i] }));

      const lines = [
        { value: mean, color: '#111827', dash: [], label: `Mean: ${mean.toFixed(3)}`, labelBg: '#111827' },
        { value: lcl, color: '#7c3aed', dash: [6, 6], label: `LCL: ${lcl.toFixed(3)}`, labelBg: '#7c3aed' },
        { value: ucl, color: '#7c3aed', dash: [6, 6], label: `UCL: ${ucl.toFixed(3)}`, labelBg: '#7c3aed' }
      ];

      if (targetValueOrNull !== null && isFinite(targetValueOrNull)) {
        lines.push({ value: targetValueOrNull, color: '#16a34a', dash: [2, 3], label: `Target: ${Number(targetValueOrNull).toFixed(2)}`, labelBg: '#16a34a' });
      }

      // Font sizes - increase for print to ensure readability (browser renders smaller in print)
      const titleFontSize = isPrint ? 17 : 14;
      const axisFontSize = isPrint ? 15 : 12;
      const legendFontSize = isPrint ? 14 : 12;
      const printFontFamily = 'Arial, sans-serif';

      const chart = new Chart(ctx, {
        type: 'bar',
        data: {
          datasets: [
            {
              type: 'bar',
              label: 'Histogram',
              data: bars,
              parsing: false,
              backgroundColor: 'rgba(54, 162, 235, 0.60)',
              borderColor: 'rgba(54, 162, 235, 0.90)',
              borderWidth: isPrint ? 2 : 1,
              barThickness: 'flex'
            },
            {
              type: 'line',
              label: 'Normal Curve',
              data: curve,
              parsing: false,
              borderColor: '#e74c3c',
              borderWidth: isPrint ? 3 : 2,
              tension: 0.35,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: titleText,
              font: { size: titleFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
            },
            legend: {
              display: true,
              labels: {
                font: { size: legendFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined },
                boxWidth: isPrint ? 20 : 12,
                padding: isPrint ? 12 : 8
              }
            },
            limitLinesPlugin: { lines }
          },
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'Sliver Weight (g/m)',
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              },
              ticks: {
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Frequency',
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              },
              ticks: {
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              }
            }
          }
        }
      });

      chartMap.set(canvasId, chart);
    }

    function renderGroupedCharts(groups, productsPresent, containerId, chartMap, targets, rangePctOrRanges) {
      destroyChartMap(chartMap, containerId);
      const container = document.getElementById(containerId);

      // Support both old format (single range) and new format (per-product ranges object)
      const ranges = typeof rangePctOrRanges === 'object' && rangePctOrRanges !== null && !isFinite(rangePctOrRanges)
        ? rangePctOrRanges
        : null;
      const defaultRange = typeof rangePctOrRanges === 'number' ? rangePctOrRanges : 5.0;

      for (const p of productsPresent) {
        const g = groups[p];
        if (!g || g.allValues.length === 0) continue;

        const target = (targets && targets[p] !== undefined) ? targets[p] : null;
        const productRange = ranges && ranges[p] !== undefined ? ranges[p] : defaultRange;

        // Card averages chart
        {
          const id = `${containerId}_cardavg_${safeId(p)}`;
          container.appendChild(makeChartCard(`${p} — Distribution (Card Averages)`, id));
          const mean = meanOf(g.cardAvgs);
          const { lcl, ucl } = limitsFromMean(mean, productRange);
          plotDistribution(id, g.cardAvgs, mean, lcl, ucl, `Product: ${p} (Card Averages)`, chartMap, target);
        }

        // All coilers chart
        {
          const id = `${containerId}_all_${safeId(p)}`;
          container.appendChild(makeChartCard(`${p} — Distribution (All Coiler Readings)`, id));
          const mean = meanOf(g.allValues);
          const { lcl, ucl } = limitsFromMean(mean, productRange);
          plotDistribution(id, g.allValues, mean, lcl, ucl, `Product: ${p} (All Coiler Readings)`, chartMap, target);
        }
      }
    }

    function makeChartCard(title, canvasId) {
      const wrap = document.createElement('div');
      wrap.className = 'chart-card';
      const h = document.createElement('h3');
      h.textContent = title;
      wrap.appendChild(h);
      const canvas = document.createElement('canvas');
      canvas.id = canvasId;
      wrap.appendChild(canvas);
      return wrap;
    }

    function destroyChartMap(chartMap, containerId) {
      for (const ch of chartMap.values()) ch.destroy();
      chartMap.clear();
      const container = document.getElementById(containerId);
      if (container) container.innerHTML = '';
    }

    // -----------------------------
    // Calculate (OOC checks use Target ±5%)
    // -----------------------------
    function calculateResults() {
      try {
        const anyValues = cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));
        if (!anyValues) { alert('Please enter coiler weights (at least one value).'); return; }

        if (!validatePerCardRulesOrAlert(cardRows)) return;

        const targets = getTargets();
        if (!validateTargetsForUsedProductsOrAlert(cardRows, targets)) return;

        const acceptableRanges = getAcceptableRanges();
        const groups = groupData(cardRows);
        const productsPresent = Object.keys(groups)
          .filter(p => groups[p].allValues.length > 0)
          .sort((a, b) => a.localeCompare(b));

        if (!productsPresent.length) { alert('No valid product groups found.'); return; }

        // Clear row highlighting
        for (const r of cardRows) {
          const tr = document.getElementById(`cardRow_${r.cardNo}`);
          if (tr) tr.classList.remove('out-of-control');
        }

        let oocCardsAll = 0;
        let oocCoilersAll = 0;

        const summaryByProduct = {};
        const productStats = {};
        const outOfControlCardNos = [];

        // OOC computations are per product, using per-product ranges
        for (const p of productsPresent) {
          const g = groups[p];
          const productRange = acceptableRanges[p] || 5.0;

          // Chart-level stats (mean-based)
          const meanCard = meanOf(g.cardAvgs);
          const limCardMean = limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(g.allValues);
          const limAllMean = limitsFromMean(meanAll, productRange);

          // OOC limits (target-based when available; targets are required by validation for used products)
          const tgt = targets[p];
          const limTarget = (tgt !== null && isFinite(tgt)) ? limitsFromTarget(tgt, productRange) : null;
          const limCardOOC = limTarget || limCardMean;
          const limCoilerOOC = limTarget || limAllMean;

          let oocCards = 0;
          let oocCoilers = 0;

          for (const r of cardRows) {
            if ((r.product || '').trim() !== p) continue;

            // Card average OOC
            if (r.avg !== null && isFinite(r.avg)) {
              if (!withinLimits(Number(r.avg), limCardOOC)) {
                oocCards++;
                oocCardsAll++;
                outOfControlCardNos.push(r.cardNo);
                const tr = document.getElementById(`cardRow_${r.cardNo}`);
                if (tr) tr.classList.add('out-of-control');
              }
            }

            // Individual coilers OOC
            for (const v of (r.coilers || [])) {
              if (v === null || !isFinite(v)) continue;
              if (!withinLimits(Number(v), limCoilerOOC)) {
                oocCoilers++;
                oocCoilersAll++;
              }
            }
          }

          summaryByProduct[p] = { cards: g.cardAvgs.length, meanCardAvg: meanCard };

          // Calculate min/max for card averages and coiler readings
          const cardAvgMin = g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs) : null;
          const cardAvgMax = g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs) : null;
          const coilerMin = g.allValues.length > 0 ? Math.min(...g.allValues) : null;
          const coilerMax = g.allValues.length > 0 ? Math.max(...g.allValues) : null;

          productStats[p] = {
            countCards: g.cardAvgs.length,
            countCoilerValues: g.allValues.length,

            // Chart stats (mean-based)
            cardAvgMean: meanCard,
            cardAvgLCL: limCardMean.lcl,
            cardAvgUCL: limCardMean.ucl,
            cardAvgMin,
            cardAvgMax,

            allMean: meanAll,
            allLCL: limAllMean.lcl,
            allUCL: limAllMean.ucl,
            coilerMin,
            coilerMax,

            // OOC stats (target-based)
            target: tgt,
            targetLCL: limCardOOC.lcl,
            targetUCL: limCardOOC.ucl,
            oocCards,
            oocCoilers
          };
        }

        // Build metrics HTML: first box for products, then per-product boxes
        const metricsContainer = document.getElementById('metrics');
        let metricsHTML = `
        <div class="metric">
          <div class="label">Products Detected</div>
          <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
        </div>
      `;

        // Calculate total cards and coilers per product
        const totalCardsPerProduct = {};
        const totalCoilersPerProduct = {};
        for (const p of productsPresent) {
          totalCardsPerProduct[p] = groups[p].cardAvgs.length;
          totalCoilersPerProduct[p] = groups[p].allValues.length;
        }

        // Add per-product metrics (2 boxes per product: cards and coilers)
        for (const p of productsPresent) {
          const productRange = acceptableRanges[p] || 5.0;
          const rangeStr = productRange.toFixed(1);
          const totalCards = totalCardsPerProduct[p];
          const totalCoilers = totalCoilersPerProduct[p];
          const oocCards = productStats[p].oocCards || 0;
          const oocCoilers = productStats[p].oocCoilers || 0;
          const cardsBg = oocCards > 0 ? '#e74c3c' : '#3498db';
          const coilersBg = oocCoilers > 0 ? '#e74c3c' : '#3498db';

          const cardMin = productStats[p].cardAvgMin !== null ? productStats[p].cardAvgMin.toFixed(2) : '-';
          const cardMax = productStats[p].cardAvgMax !== null ? productStats[p].cardAvgMax.toFixed(2) : '-';
          const coilerMinVal = productStats[p].coilerMin !== null ? productStats[p].coilerMin.toFixed(3) : '-';
          const coilerMaxVal = productStats[p].coilerMax !== null ? productStats[p].coilerMax.toFixed(3) : '-';

          metricsHTML += `
          <div class="metric" style="background: ${cardsBg};">
            <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCards} out of ${totalCards}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
          </div>
          <div class="metric" style="background: ${coilersBg};">
            <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCoilers} out of ${totalCoilers}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${coilerMinVal} | Max: ${coilerMaxVal}</div>
          </div>
        `;
        }

        metricsContainer.innerHTML = metricsHTML;
        metricsContainer.style.display = 'flex';

        // Store out-of-control card numbers for warning
        // (Already populated in the loop above: outOfControlCardNos)

        currentTest = {
          reportNumber: document.getElementById('reportNumber').value,
          operatorName: document.getElementById('operatorName').value.trim(),
          testDate: document.getElementById('testDate').value,
          dateTime: new Date().toLocaleString(),
          productsPresent,
          targets,
          acceptableRanges,
          productStats,
          summaryByProduct,
          cardRows: JSON.parse(JSON.stringify(cardRows)),
          oocCardsAll,
          oocCoilersAll,
          outOfControlCardNos
        };

        // Charts grouped by product (mean-based limits shown; target line also shown)
        renderGroupedCharts(groups, productsPresent, 'chartsGrid', chartInstances, targets, acceptableRanges);

        // Show and enable buttons after calculation
        document.getElementById('saveBtn').style.display = 'inline-block';
        document.getElementById('printCurrentBtn').style.display = 'none'; // Print Current button is only shown after saving
        enableSavePrintButtons();
        isDataCalculated = true;
      } catch (e) {
        showError("Calculate failed: " + (e && e.message ? e.message : String(e)));
        console.error(e);
      }
    }

    // -----------------------------
    // Save / Load / Delete / Details
    // -----------------------------
    function saveTest(e) {
      if (e) e.preventDefault();
      try {
        if (!currentTest) { alert('Please calculate results before saving.'); return; }

        // Check if there are out-of-control cards or coilers
        if ((currentTest.oocCardsAll && currentTest.oocCardsAll > 0) || (currentTest.oocCoilersAll && currentTest.oocCoilersAll > 0)) {
          const cardMsg = currentTest.oocCardsAll > 0 ? `${currentTest.oocCardsAll} card(s) out of range. ` : '';
          const coilerMsg = currentTest.oocCoilersAll > 0 ? `${currentTest.oocCoilersAll} coiler reading(s) out of range.` : '';
          const message = `${cardMsg}${coilerMsg}<br><br>Do you want to continue saving?`;

          // Show Custom Modal
          document.getElementById('saveConfirmMessage').innerHTML = message;
          document.getElementById('saveConfirmModal').style.display = 'flex';
          return; // Stop here, wait for modal
        }

        // If no warnings, save immediately
        finalizeSave();

      } catch (e) {
        alert("Error initiating save: " + e.message);
        console.error(e);
      }
    }

    function finalizeSave() {
      try {
        const saved = getSavedTests();
        saved.push(currentTest);
        setSavedTests(saved);
        alert('Test saved successfully.');
        document.getElementById('saveBtn').style.display = 'none';

        // Show Print Current button after saving (enabled since data is calculated)
        document.getElementById('printCurrentBtn').style.display = 'inline-block';
        enableSavePrintButtons();

        // Mark data as saved
        hasUnsavedData = false;
        isTestSaved = true;

        loadSavedTests();
      } catch (e) {
        alert("Error saving test: " + e.message);
        console.error(e);
      }
    }

    function formatProductSummary(summaryByProduct) {
      const keys = Object.keys(summaryByProduct || {});
      if (!keys.length) return '-';
      return keys
        .sort((a, b) => a.localeCompare(b))
        .map(p => `${p}: ${summaryByProduct[p].meanCardAvg.toFixed(2)} (n=${summaryByProduct[p].cards})`)
        .join(' | ');
    }

    function loadSavedTests() {
      const tbody = document.getElementById('savedList');
      const saved = getSavedTests();
      if (!saved.length) {
        tbody.innerHTML = '<tr><td colspan="8">No saved tests yet.</td></tr>';
        document.getElementById('deleteBtn').style.display = 'none';
        document.getElementById('printSelectedBtn').style.display = 'none';
        return;
      }

      tbody.innerHTML = '';
      saved.slice().reverse().forEach((test, revIndex) => {
        const summary = formatProductSummary(test.summaryByProduct);
        const targetsText = formatTargets(test.targets);

        const tr = document.createElement('tr');
        tr.innerHTML = `
        <td><input type="checkbox" onchange="onSavedSelectionChanged()"></td>
        <td>${escapeHtml(test.dateTime || 'N/A')}</td>
        <td>${escapeHtml(test.reportNumber || 'N/A')}</td>
        <td>${escapeHtml(test.testDate || 'N/A')}</td>
        <td>${escapeHtml(test.operatorName || 'N/A')}</td>
        <td style="text-align:left;">${escapeHtml(targetsText)}</td>
        <td style="text-align:left;">${escapeHtml(summary)}</td>
        <td><button class="btn-muted" style="margin:0; padding:8px 12px;" onclick="viewDetailsByRow(event, ${revIndex})">View Details</button></td>
      `;
        tbody.appendChild(tr);
      });

      document.getElementById('deleteBtn').style.display = 'none';
      document.getElementById('printSelectedBtn').style.display = 'none';
    }

    function viewDetailsByRow(event, revIndex) {
      event.preventDefault();
      event.stopPropagation();
      const saved = getSavedTests();
      const originalIndex = saved.length - 1 - revIndex;
      const test = saved[originalIndex];
      if (!test) return;
      openDetails(test);
    }

    function onSavedSelectionChanged() {
      const anyChecked = getSelectedSavedIndices().length > 0;
      document.getElementById('deleteBtn').style.display = anyChecked ? 'inline-block' : 'none';
      document.getElementById('printSelectedBtn').style.display = anyChecked ? 'inline-block' : 'none';
    }

    function toggleSelectAll(master) {
      const checkboxes = document.querySelectorAll('#savedList input[type="checkbox"]');
      checkboxes.forEach(cb => cb.checked = master.checked);
      onSavedSelectionChanged();
    }

    function getSelectedSavedIndices() {
      const checkboxes = document.querySelectorAll('#savedList input[type="checkbox"]');
      const saved = getSavedTests();
      const selected = [];
      checkboxes.forEach((cb, rowIndex) => {
        if (!cb.checked) return;
        // If filters are active, use filteredTests; otherwise use all saved tests
        const testsList = filteredTests.length > 0 ? filteredTests : saved;
        const revIndex = testsList.length - 1 - rowIndex;
        const test = testsList[revIndex];
        if (test) {
          const originalIndex = saved.indexOf(test);
          if (originalIndex >= 0) selected.push(originalIndex);
        }
      });
      return selected;
    }

    function deleteSelected() {
      const selected = new Set(getSelectedSavedIndices());
      if (selected.size === 0) return;
      if (!confirm('Are you sure you want to delete the selected tests?')) return;

      const saved = getSavedTests();
      const kept = saved.filter((_, idx) => !selected.has(idx));
      setSavedTests(kept);
      loadSavedTests();
      closeDetails();
    }

    // -----------------------------
    // Filtering functionality
    // -----------------------------
    let filteredTests = [];
    const filteredChartInstances = new Map();

    function switchFilterTab(tab) {
      document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.filter-content').forEach(c => c.classList.remove('active'));

      if (tab === 'date') {
        document.querySelectorAll('.filter-tab')[0].classList.add('active');
        document.getElementById('filterDate').classList.add('active');
      } else if (tab === 'cards') {
        document.querySelectorAll('.filter-tab')[1].classList.add('active');
        document.getElementById('filterCards').classList.add('active');
      } else if (tab === 'combined') {
        document.querySelectorAll('.filter-tab')[2].classList.add('active');
        document.getElementById('filterCombined').classList.add('active');
      }
    }

    function onDateRangeTypeChange() {
      const type = document.getElementById('dateRangeType').value;
      document.getElementById('customDateRange').style.display = type === 'custom' ? 'flex' : 'none';
    }

    function onCombinedDateRangeTypeChange() {
      const type = document.getElementById('combinedDateRangeType').value;
      document.getElementById('combinedCustomDateRange').style.display = type === 'custom' ? 'flex' : 'none';
    }

    function getDateRange(type) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (type === 'today') {
        return { from: new Date(today), to: new Date(today) };
      } else if (type === 'week') {
        const from = new Date(today);
        from.setDate(today.getDate() - today.getDay());
        const to = new Date(from);
        to.setDate(from.getDate() + 6);
        return { from, to };
      } else if (type === 'month') {
        const from = new Date(today.getFullYear(), today.getMonth(), 1);
        const to = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        return { from, to };
      }
      return null;
    }

    function getSelectedCards(selectorId) {
      const checkboxes = document.querySelectorAll(`#${selectorId} input[type="checkbox"]:checked`);
      return Array.from(checkboxes).map(cb => parseInt(cb.value));
    }

    function getSelectedProducts(selectorId) {
      const checkboxes = document.querySelectorAll(`#${selectorId} input[type="checkbox"]:checked`);
      return Array.from(checkboxes).map(cb => cb.value);
    }

    function selectAllProducts(selectorId) {
      document.querySelectorAll(`#${selectorId} input[type="checkbox"]`).forEach(cb => cb.checked = true);
      applyFilters();
    }

    function deselectAllProducts(selectorId) {
      document.querySelectorAll(`#${selectorId} input[type="checkbox"]`).forEach(cb => cb.checked = false);
      applyFilters();
    }

    function applyFilters() {
      const saved = getSavedTests();
      let filtered = [...saved];

      // Get active tab
      const activeTab = document.querySelector('.filter-tab.active');
      const tabIndex = Array.from(document.querySelectorAll('.filter-tab')).indexOf(activeTab);

      if (tabIndex === 0 || tabIndex === 2) {
        // Date filter
        const dateRangeType = tabIndex === 0
          ? document.getElementById('dateRangeType').value
          : document.getElementById('combinedDateRangeType').value;

        let dateFrom, dateTo;
        if (dateRangeType === 'custom') {
          const fromInput = tabIndex === 0 ? document.getElementById('filterDateFrom') : document.getElementById('combinedDateFrom');
          const toInput = tabIndex === 0 ? document.getElementById('filterDateTo') : document.getElementById('combinedDateTo');
          if (fromInput.value) dateFrom = new Date(fromInput.value + 'T00:00:00');
          if (toInput.value) {
            dateTo = new Date(toInput.value + 'T23:59:59.999');
          }
        } else {
          const range = getDateRange(dateRangeType);
          if (range) {
            dateFrom = range.from;
            dateTo = range.to;
            dateTo.setHours(23, 59, 59, 999);
          }
        }

        if (dateFrom || dateTo) {
          filtered = filtered.filter(test => {
            if (!test.testDate) return false;
            // Handle different date formats
            let testDateStr = test.testDate;
            if (testDateStr.includes('T')) {
              testDateStr = testDateStr.split('T')[0]; // Get date part only (YYYY-MM-DD)
            }
            const testDate = new Date(testDateStr + 'T00:00:00');
            if (isNaN(testDate.getTime())) return false; // Invalid date

            if (dateFrom) {
              const fromDate = new Date(dateFrom);
              fromDate.setHours(0, 0, 0, 0);
              if (testDate < fromDate) return false;
            }
            if (dateTo) {
              const toDate = new Date(dateTo);
              toDate.setHours(23, 59, 59, 999);
              if (testDate > toDate) return false;
            }
            return true;
          });
        }

        // Operator filter
        const operator = tabIndex === 0
          ? document.getElementById('filterOperator').value
          : document.getElementById('combinedOperator').value;
        if (operator) {
          filtered = filtered.filter(test => test.operatorName === operator);
        }
      }

      if (tabIndex === 1 || tabIndex === 2) {
        // Card filter
        const selectorId = tabIndex === 1 ? 'cardSelector' : 'combinedCardSelector';
        const selectedCards = getSelectedCards(selectorId);
        if (selectedCards.length > 0) {
          filtered = filtered.map(test => {
            const filteredCardRows = (test.cardRows || []).filter(r => selectedCards.includes(r.cardNo));
            if (filteredCardRows.length === 0) return null;
            return { ...test, cardRows: filteredCardRows };
          }).filter(Boolean);
        }
      }

      // Product filter (applies to all tabs)
      let productSelectorId;
      if (tabIndex === 0) {
        productSelectorId = 'filterProductSelector';
      } else if (tabIndex === 1) {
        productSelectorId = 'cardProductSelector';
      } else {
        productSelectorId = 'combinedProductSelector';
      }
      const selectedProducts = getSelectedProducts(productSelectorId);
      const hasCustomProductSelected = selectedProducts.includes('__CUSTOM_PRODUCT__');
      const regularSelectedProducts = selectedProducts.filter(p => p !== '__CUSTOM_PRODUCT__');

      if (selectedProducts.length > 0) {
        filtered = filtered.filter(test => {
          // Get products from test
          const testGroups = groupData(test.cardRows || []);
          const testProducts = Object.keys(testGroups).filter(p => testGroups[p].allValues.length > 0);

          let matchesCustom = false;
          let matchesRegular = false;

          // Check if test matches custom product filter
          if (hasCustomProductSelected) {
            // Check if test has any products that are NOT in the standard product list
            matchesCustom = testProducts.some(p => !PRODUCT_OPTIONS_BASE.includes(p));
          }

          // Check if test matches regular product filter
          if (regularSelectedProducts.length > 0) {
            matchesRegular = testProducts.some(p => regularSelectedProducts.includes(p));
          }

          // Return true if either custom or regular products match
          if (hasCustomProductSelected && regularSelectedProducts.length > 0) {
            return matchesCustom || matchesRegular;
          } else if (hasCustomProductSelected) {
            return matchesCustom;
          } else {
            return matchesRegular;
          }
        });
      }

      // Determine if any filters were actually applied
      let filtersApplied = false;

      if (tabIndex === 0 || tabIndex === 2) {
        // Check date filter
        const dateRangeType = tabIndex === 0
          ? document.getElementById('dateRangeType').value
          : document.getElementById('combinedDateRangeType').value;
        if (dateRangeType && dateRangeType !== '') {
          filtersApplied = true;
        }
        // Check operator filter
        const operator = tabIndex === 0
          ? document.getElementById('filterOperator').value
          : document.getElementById('combinedOperator').value;
        if (operator && operator !== '') {
          filtersApplied = true;
        }
      }

      if (tabIndex === 1 || tabIndex === 2) {
        // Check card filter
        const selectorId = tabIndex === 1 ? 'cardSelector' : 'combinedCardSelector';
        const selectedCards = getSelectedCards(selectorId);
        if (selectedCards.length > 0) {
          filtersApplied = true;
        }
      }

      // Check product filter
      if (selectedProducts.length > 0) {
        filtersApplied = true;
      }

      // Update filteredTests only if filters are actually applied
      filteredTests = filtersApplied ? filtered : [];

      // Update table display
      const tbody = document.getElementById('savedList');
      if (filtered.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8">No tests match the filter criteria.</td></tr>';
      } else {
        tbody.innerHTML = '';
        const displayTests = filteredTests.length > 0 ? filteredTests : saved;
        displayTests.slice().reverse().forEach((test, revIndex) => {
          const originalIndex = saved.indexOf(test);
          const revOriginalIndex = saved.length - 1 - originalIndex;
          const summary = formatProductSummary(test.summaryByProduct);
          const targetsText = formatTargets(test.targets);

          const tr = document.createElement('tr');
          tr.innerHTML = `
          <td><input type="checkbox" onchange="onSavedSelectionChanged()"></td>
          <td>${escapeHtml(test.dateTime || 'N/A')}</td>
          <td>${escapeHtml(test.reportNumber || 'N/A')}</td>
          <td>${escapeHtml(test.testDate || 'N/A')}</td>
          <td>${escapeHtml(test.operatorName || 'N/A')}</td>
          <td style="text-align:left;">${escapeHtml(targetsText)}</td>
          <td style="text-align:left;">${escapeHtml(summary)}</td>
          <td><button class="btn-muted" style="margin:0; padding:8px 12px;" onclick="viewDetailsByRow(event, ${revOriginalIndex})">View Details</button></td>
        `;
          tbody.appendChild(tr);
        });
      }

      // Show view button if filters applied and results exist
      if (filteredTests.length > 0) {
        const viewBtn = tabIndex === 0 ? 'viewFilteredBtn' : (tabIndex === 1 ? 'viewFilteredCardsBtn' : 'viewFilteredCombinedBtn');
        document.getElementById(viewBtn).style.display = 'inline-block';
      } else {
        document.getElementById('viewFilteredBtn').style.display = 'none';
        document.getElementById('viewFilteredCardsBtn').style.display = 'none';
        document.getElementById('viewFilteredCombinedBtn').style.display = 'none';
      }
    }

    function clearFilters() {
      document.getElementById('dateRangeType').value = '';
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterOperator').value = '';
      document.getElementById('combinedDateRangeType').value = '';
      document.getElementById('combinedDateFrom').value = '';
      document.getElementById('combinedDateTo').value = '';
      document.getElementById('combinedOperator').value = '';

      document.querySelectorAll('#cardSelector input[type="checkbox"], #combinedCardSelector input[type="checkbox"]').forEach(cb => cb.checked = false);
      document.querySelectorAll('#filterProductSelector input[type="checkbox"], #cardProductSelector input[type="checkbox"], #combinedProductSelector input[type="checkbox"]').forEach(cb => cb.checked = false);

      document.getElementById('customDateRange').style.display = 'none';
      document.getElementById('combinedCustomDateRange').style.display = 'none';

      filteredTests = [];
      document.getElementById('filteredResultsPanel').style.display = 'none';
      document.getElementById('viewFilteredBtn').style.display = 'none';
      document.getElementById('viewFilteredCardsBtn').style.display = 'none';
      document.getElementById('viewFilteredCombinedBtn').style.display = 'none';

      loadSavedTests();
    }

    function selectAllCards() {
      const activeTab = document.querySelector('.filter-tab.active');
      const tabIndex = Array.from(document.querySelectorAll('.filter-tab')).indexOf(activeTab);
      const selectorId = tabIndex === 1 ? 'cardSelector' : 'combinedCardSelector';
      document.querySelectorAll(`#${selectorId} input[type="checkbox"]`).forEach(cb => cb.checked = true);
    }

    function deselectAllCards() {
      const activeTab = document.querySelector('.filter-tab.active');
      const tabIndex = Array.from(document.querySelectorAll('.filter-tab')).indexOf(activeTab);
      const selectorId = tabIndex === 1 ? 'cardSelector' : 'combinedCardSelector';
      document.querySelectorAll(`#${selectorId} input[type="checkbox"]`).forEach(cb => cb.checked = false);
    }

    function viewFilteredResults() {
      if (filteredTests.length === 0) {
        alert('No filtered tests to display.');
        return;
      }

      // Get selected products from the active filter tab
      const activeTab = document.querySelector('.filter-tab.active');
      const tabIndex = Array.from(document.querySelectorAll('.filter-tab')).indexOf(activeTab);
      let productSelectorId;
      if (tabIndex === 0) {
        productSelectorId = 'filterProductSelector';
      } else if (tabIndex === 1) {
        productSelectorId = 'cardProductSelector';
      } else {
        productSelectorId = 'combinedProductSelector';
      }
      let selectedProducts = getSelectedProducts(productSelectorId);

      // Handle "Custom Product" selection - replace __CUSTOM_PRODUCT__ with actual custom product names
      if (selectedProducts.includes('__CUSTOM_PRODUCT__')) {
        const customProducts = new Set();
        for (const test of filteredTests) {
          const groups = groupData(test.cardRows || []);
          Object.keys(groups).forEach(p => {
            if (!PRODUCT_OPTIONS_BASE.includes(p)) {
              customProducts.add(p);
            }
          });
        }
        selectedProducts = selectedProducts.filter(p => p !== '__CUSTOM_PRODUCT__');
        selectedProducts.push(...Array.from(customProducts));
      }

      // Group data by product across all filtered tests (never combine different products)
      const combinedGroups = {};
      const allTargets = {};
      const allRanges = {};

      for (const test of filteredTests) {
        const groups = groupData(test.cardRows || []);
        for (const p of Object.keys(groups)) {
          // If products are selected, only include selected products
          if (selectedProducts.length > 0 && !selectedProducts.includes(p)) {
            continue;
          }
          if (!combinedGroups[p]) {
            combinedGroups[p] = { cardAvgs: [], allValues: [], cardNos: [] };
            allTargets[p] = test.targets && test.targets[p] ? test.targets[p] : null;
            // Use per-product ranges if available, otherwise fallback to single range
            if (test.acceptableRanges && test.acceptableRanges[p]) {
              allRanges[p] = test.acceptableRanges[p];
            } else if (test.acceptableRange !== undefined && test.acceptableRange !== null) {
              allRanges[p] = test.acceptableRange;
            } else {
              allRanges[p] = 5.0;
            }
          }
          combinedGroups[p].cardAvgs.push(...groups[p].cardAvgs);
          combinedGroups[p].allValues.push(...groups[p].allValues);
          combinedGroups[p].cardNos.push(...groups[p].cardNos);
        }
      }

      const productsPresent = Object.keys(combinedGroups)
        .filter(p => combinedGroups[p].allValues.length > 0)
        .sort((a, b) => a.localeCompare(b));

      if (productsPresent.length === 0) {
        alert('No data to display after filtering.');
        return;
      }

      // Calculate metrics for filtered results - per product (only selected products)
      const productMetrics = {};
      for (const test of filteredTests) {
        const testGroups = groupData(test.cardRows || []);
        const testRanges = test.acceptableRanges || (test.acceptableRange !== undefined && test.acceptableRange !== null
          ? Object.fromEntries(Object.keys(testGroups).map(p => [p, test.acceptableRange]))
          : Object.fromEntries(Object.keys(testGroups).map(p => [p, 5.0])));

        for (const p of Object.keys(testGroups)) {
          // If products are selected, only include selected products
          if (selectedProducts.length > 0 && !selectedProducts.includes(p)) {
            continue;
          }
          if (!productMetrics[p]) {
            productMetrics[p] = { totalCards: 0, totalCoilers: 0, oocCards: 0, oocCoilers: 0, range: testRanges[p] || 5.0, cardAvgs: [], allValues: [] };
          }
          const g = testGroups[p];
          productMetrics[p].totalCards += g.cardAvgs.length;
          productMetrics[p].totalCoilers += g.allValues.length;
          productMetrics[p].cardAvgs.push(...g.cardAvgs);
          productMetrics[p].allValues.push(...g.allValues);

          // Calculate OOC for this test's product data
          const productRange = testRanges[p] || 5.0;
          const tgt = test.targets && test.targets[p] ? test.targets[p] : null;
          const meanCard = meanOf(g.cardAvgs);
          const limCard = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(g.allValues);
          const limCoiler = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanAll, productRange);

          for (const r of test.cardRows || []) {
            if ((r.product || '').trim() !== p) continue;
            if (r.avg !== null && isFinite(r.avg) && !withinLimits(Number(r.avg), limCard)) {
              productMetrics[p].oocCards++;
            }
            for (const v of (r.coilers || [])) {
              if (v !== null && isFinite(v) && !withinLimits(Number(v), limCoiler)) {
                productMetrics[p].oocCoilers++;
              }
            }
          }
        }
      }

      // Display metrics boxes - per product
      const filteredMetrics = document.getElementById('filteredMetrics');
      let filteredMetricsHTML = `
      <div class="metric">
        <div class="label">Products Detected</div>
        <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
      </div>
    `;

      for (const p of productsPresent) {
        const metrics = productMetrics[p] || { totalCards: 0, totalCoilers: 0, oocCards: 0, oocCoilers: 0, range: allRanges[p] || 5.0, cardAvgs: [], allValues: [] };
        const rangeStr = metrics.range.toFixed(1);
        const cardsBg = metrics.oocCards > 0 ? '#e74c3c' : '#3498db';
        const coilersBg = metrics.oocCoilers > 0 ? '#e74c3c' : '#3498db';

        const cardMin = metrics.cardAvgs && metrics.cardAvgs.length > 0 ? Math.min(...metrics.cardAvgs).toFixed(3) : '-';
        const cardMax = metrics.cardAvgs && metrics.cardAvgs.length > 0 ? Math.max(...metrics.cardAvgs).toFixed(3) : '-';
        const coilerMin = metrics.allValues && metrics.allValues.length > 0 ? Math.min(...metrics.allValues).toFixed(3) : '-';
        const coilerMax = metrics.allValues && metrics.allValues.length > 0 ? Math.max(...metrics.allValues).toFixed(3) : '-';

        filteredMetricsHTML += `
        <div class="metric" style="background: ${cardsBg};">
          <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCards} out of ${metrics.totalCards}</div>
          <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
        </div>
        <div class="metric" style="background: ${coilersBg};">
          <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCoilers} out of ${metrics.totalCoilers}</div>
          <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${coilerMin} | Max: ${coilerMax}</div>
        </div>
      `;
      }

      filteredMetrics.innerHTML = filteredMetricsHTML;

      // Display filtered results panel
      document.getElementById('filteredResultsPanel').style.display = 'block';
      document.getElementById('filteredResultsPanel').scrollIntoView({ behavior: 'smooth', block: 'start' });

      // Render charts product-wise
      renderGroupedCharts(combinedGroups, productsPresent, 'filteredChartsGrid', filteredChartInstances, allTargets, allRanges);
    }

    function closeFilteredResults() {
      document.getElementById('filteredResultsPanel').style.display = 'none';
      destroyChartMap(filteredChartInstances, 'filteredChartsGrid');
    }

    function printFilteredResults() {
      if (filteredTests.length === 0) {
        alert('No filtered tests to print.');
        return;
      }

      // Get selected products from the active filter tab
      const activeTab = document.querySelector('.filter-tab.active');
      const tabIndex = Array.from(document.querySelectorAll('.filter-tab')).indexOf(activeTab);
      let productSelectorId;
      if (tabIndex === 0) {
        productSelectorId = 'filterProductSelector';
      } else if (tabIndex === 1) {
        productSelectorId = 'cardProductSelector';
      } else {
        productSelectorId = 'combinedProductSelector';
      }
      let selectedProducts = getSelectedProducts(productSelectorId);

      // Handle "Custom Product" selection - replace __CUSTOM_PRODUCT__ with actual custom product names
      if (selectedProducts.includes('__CUSTOM_PRODUCT__')) {
        const customProducts = new Set();
        for (const test of filteredTests) {
          const groups = groupData(test.cardRows || []);
          Object.keys(groups).forEach(p => {
            if (!PRODUCT_OPTIONS_BASE.includes(p)) {
              customProducts.add(p);
            }
          });
        }
        selectedProducts = selectedProducts.filter(p => p !== '__CUSTOM_PRODUCT__');
        selectedProducts.push(...Array.from(customProducts));
      }

      // Create a comprehensive print view with charts and sorted table
      printFromTestsWithTable(filteredTests, `Filtered Results (${filteredTests.length} tests)`, selectedProducts);
    }

    function printFromTestsWithTable(tests, modeLabel, selectedProducts = []) {
      const printSection = document.getElementById('printSection');
      const printMeta = document.getElementById('printMeta');
      const printChartsContainer = document.getElementById('printChartsContainer');
      const printTablesContainer = document.getElementById('printTablesContainer');

      document.getElementById('printTitle').textContent = `Card Sliver Weight Monitoring — ${modeLabel}`;

      // Handle "Custom Product" selection - replace __CUSTOM_PRODUCT__ with actual custom product names
      if (selectedProducts.includes('__CUSTOM_PRODUCT__')) {
        const customProducts = new Set();
        for (const t of tests) {
          const g = groupData(t.cardRows || []);
          Object.keys(g).forEach(p => {
            if (!PRODUCT_OPTIONS_BASE.includes(p)) {
              customProducts.add(p);
            }
          });
        }
        selectedProducts = selectedProducts.filter(p => p !== '__CUSTOM_PRODUCT__');
        selectedProducts.push(...Array.from(customProducts));
      }

      // Combine by product across tests for printing (never combine different products)
      const combinedGroups = {};
      for (const t of tests) {
        const g = groupData(t.cardRows || []);
        for (const p of Object.keys(g)) {
          // If products are selected, only include selected products
          if (selectedProducts.length > 0 && !selectedProducts.includes(p)) {
            continue;
          }
          if (!combinedGroups[p]) combinedGroups[p] = { cardAvgs: [], allValues: [], cardNos: [] };
          combinedGroups[p].cardAvgs.push(...g[p].cardAvgs);
          combinedGroups[p].allValues.push(...g[p].allValues);
          combinedGroups[p].cardNos.push(...g[p].cardNos);
        }
      }
      const productsPresent = Object.keys(combinedGroups)
        .filter(p => combinedGroups[p].allValues.length > 0)
        .sort((a, b) => a.localeCompare(b));

      const reportNums = tests.map(t => t.reportNumber).filter(Boolean).join(', ');
      const testDates = Array.from(new Set(tests.map(t => t.testDate).filter(Boolean))).join(', ');
      const operators = Array.from(new Set(tests.map(t => t.operatorName).filter(Boolean))).join(', ');

      // Use the first test's range, or default to 5.0 if not available
      const printRange = (tests.length > 0 && tests[0].acceptableRange !== undefined && tests[0].acceptableRange !== null) ? tests[0].acceptableRange : 5.0;

      printMeta.innerHTML = `
      <div><strong>Report #:</strong> ${escapeHtml(reportNums || '-')}</div>
      <div><strong>Date(s):</strong> ${escapeHtml(testDates || '-')}</div>
      <div><strong>Operator(s):</strong> ${escapeHtml(operators || '-')}</div>
      <div><strong>Products:</strong> ${escapeHtml(productsPresent.join(', ') || '-')}</div>
    `;

      // Calculate per-product metrics for print header
      const printMetricsData = {};
      const printRanges = {}; // Per-product ranges

      for (const p of productsPresent) {
        const g = combinedGroups[p];
        printMetricsData[p] = { totalCards: g.cardAvgs.length, totalCoilers: g.allValues.length, oocCards: 0, oocCoilers: 0 };

        // Determine range for this product (use per-product range if available, otherwise use single range)
        let productRange = printRange;
        for (const t of tests) {
          if (t.acceptableRanges && t.acceptableRanges[p] !== undefined && t.acceptableRanges[p] !== null) {
            productRange = t.acceptableRanges[p];
            break;
          } else if (t.acceptableRange !== undefined && t.acceptableRange !== null && tests.length === 1) {
            productRange = t.acceptableRange;
          }
        }
        printRanges[p] = productRange;

        // Calculate OOC for this product from all tests
        for (const t of tests) {
          const testGroups = groupData(t.cardRows || []);
          if (!testGroups[p]) continue;

          const tgt = t.targets && t.targets[p] ? t.targets[p] : null;
          const meanCard = meanOf(testGroups[p].cardAvgs);
          const limCard = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(testGroups[p].allValues);
          const limCoiler = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanAll, productRange);

          for (const r of t.cardRows || []) {
            if ((r.product || '').trim() !== p) continue;
            if (r.avg !== null && isFinite(r.avg) && !withinLimits(Number(r.avg), limCard)) {
              printMetricsData[p].oocCards++;
            }
            for (const v of (r.coilers || [])) {
              if (v !== null && isFinite(v) && !withinLimits(Number(v), limCoiler)) {
                printMetricsData[p].oocCoilers++;
              }
            }
          }
        }
      }

      // Create metrics boxes for print with inline styles for color printing - per product
      const printMetrics = document.getElementById('printMetrics');
      let printMetricsHTML = `
      <div class="print-metric" style="background-color: #3498db !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
        <div class="label">Products Detected</div>
        <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
      </div>
    `;

      for (const p of productsPresent) {
        const metrics = printMetricsData[p];
        const g = combinedGroups[p];
        const rangeStr = printRanges[p].toFixed(1);
        const cardsBgColor = metrics.oocCards > 0 ? '#e74c3c' : '#3498db';
        const coilersBgColor = metrics.oocCoilers > 0 ? '#e74c3c' : '#3498db';

        const cardMin = g.cardAvgs && g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs).toFixed(2) : '-';
        const cardMax = g.cardAvgs && g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs).toFixed(2) : '-';
        const coilerMin = g.allValues && g.allValues.length > 0 ? Math.min(...g.allValues).toFixed(3) : '-';
        const coilerMax = g.allValues && g.allValues.length > 0 ? Math.max(...g.allValues).toFixed(3) : '-';

        printMetricsHTML += `
        <div class="print-metric" style="background-color: ${cardsBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCards} out of ${metrics.totalCards}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
        </div>
        <div class="print-metric" style="background-color: ${coilersBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCoilers} out of ${metrics.totalCoilers}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${coilerMin} | Max: ${coilerMax}</div>
        </div>
      `;
      }

      printMetrics.innerHTML = printMetricsHTML;

      printChartsContainer.innerHTML = '';
      printTablesContainer.innerHTML = '';

      // Destroy old print charts
      for (const ch of printChartInstances.values()) ch.destroy();
      printChartInstances.clear();

      // Charts grid
      const grid = document.createElement('div');
      grid.className = 'print-grid';
      printChartsContainer.appendChild(grid);

      // For combined printing, there is no single target per product (targets may differ per test),
      // so we only show target line when printing exactly one test.
      const singleTestTargets = (tests.length === 1 && tests[0].targets) ? tests[0].targets : {};

      for (let i = 0; i < productsPresent.length; i++) {
        const p = productsPresent[i];
        const g = combinedGroups[p];

        // Only show All Coiler Readings chart (not Card Averages)
        if (g.allValues.length > 0) {
          const id = `print_all_${safeId(p)}`;
          grid.appendChild(makePrintChartCard(`${p} — All Coiler Readings`, id));
          const mean = meanOf(g.allValues);
          const { lcl, ucl } = limitsFromMean(mean, printRange);
          const tval = (tests.length === 1 && singleTestTargets[p] !== null && isFinite(singleTestTargets[p])) ? singleTestTargets[p] : null;
          plotDistribution(id, g.allValues, mean, lcl, ucl, `Product: ${p} (All Coiler Readings)`, printChartInstances, tval);
        }
      }

      // Create detailed sorted table with all individual values (filter by selected products if specified)
      const allRows = [];
      for (const test of tests) {
        for (const row of test.cardRows || []) {
          const rowProduct = (row.product || '').trim();
          // If products are selected, only include rows for selected products
          if (selectedProducts.length > 0 && !selectedProducts.includes(rowProduct)) {
            continue;
          }
          allRows.push({
            ...row,
            testDate: test.testDate,
            dateTime: test.dateTime,
            reportNumber: test.reportNumber,
            operatorName: test.operatorName,
            product: rowProduct,
            target: (test.targets && test.targets[rowProduct] && test.targets[rowProduct] > 0) ? test.targets[rowProduct] : null
          });
        }
      }

      // Sort by test date, then by card number
      allRows.sort((a, b) => {
        const dateA = a.testDate ? new Date(a.testDate) : new Date(0);
        const dateB = b.testDate ? new Date(b.testDate) : new Date(0);
        if (dateA.getTime() !== dateB.getTime()) {
          return dateA.getTime() - dateB.getTime();
        }
        return a.cardNo - b.cardNo;
      });

      const tableDiv = document.createElement('div');
      tableDiv.innerHTML = `<h3 style="margin: 12px 0 8px; font-size: 14px; font-weight: bold;">Detailed Data (Sorted by Date, then Card Number)</h3>`;
      const table = document.createElement('table');
      table.style.borderCollapse = 'collapse';
      table.style.width = '100%';
      table.style.fontSize = '11px';
      table.innerHTML = `
      <thead>
        <tr style="background: #f3f4f6; font-weight: bold;">
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Test Date</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Report #</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Operator</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Card #</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Product</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Target (g/m)</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 1</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 2</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 3</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 4</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Avg</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Min</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Max</th>
        </tr>
      </thead>
      <tbody>
        ${allRows.map(r => {
        const coilers = r.coilers || [];
        return `
          <tr>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.testDate || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.reportNumber || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.operatorName || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: center; font-weight: bold;">${r.cardNo}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.product || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right; font-weight: 600;">${r.target !== null ? Number(r.target).toFixed(2) : '-'}</td>
            ${coilers.map(v => `<td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${v !== null && isFinite(v) ? Number(v).toFixed(3) : '-'}</td>`).join('')}
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right; font-weight: bold;">${r.avg !== null && isFinite(r.avg) ? Number(r.avg).toFixed(3) : '-'}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${(() => {
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            return coilerValues.length > 0 ? Math.min(...coilerValues).toFixed(3) : '-';
          })()}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${(() => {
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            return coilerValues.length > 0 ? Math.max(...coilerValues).toFixed(3) : '-';
          })()}</td>
          </tr>
        `;
      }).join('')}
      </tbody>
    `;
      tableDiv.appendChild(table);
      printTablesContainer.appendChild(tableDiv);

      // Show print view
      const mainContainer = document.querySelector('.container');
      const originalDisplay = mainContainer ? mainContainer.style.display : '';

      if (mainContainer) mainContainer.style.display = 'none';
      printSection.style.cssText = `
      display:block !important;
      visibility:visible !important;
      position:static !important;
      left:auto !important;
      top:auto !important;
      width:100% !important;
      height:auto !important;
      background:white !important;
      z-index:99999 !important;
      overflow:visible !important;
      padding:20px !important;
    `;

      const restore = () => {
        printSection.style.cssText = 'display:none; position:absolute; left:-9999px; top:0;';
        if (mainContainer) mainContainer.style.display = originalDisplay || 'block';
        for (const ch of printChartInstances.values()) ch.destroy();
        printChartInstances.clear();
      };

      window.scrollTo(0, 0);
      setTimeout(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try { window.print(); } catch (e) { alert('Print failed. Use Ctrl+P / Cmd+P.'); restore(); return; }
            const after = () => { restore(); window.removeEventListener('afterprint', after); };
            window.addEventListener('afterprint', after);
            setTimeout(restore, 1400);
          });
        });
      }, 600);
    }

    function initializeFilters() {
      // Populate operators
      const saved = getSavedTests();
      const operators = Array.from(new Set(saved.map(t => t.operatorName).filter(Boolean))).sort();
      const operatorSelects = ['filterOperator', 'combinedOperator'];
      operatorSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        if (select) {
          const currentValue = select.value;
          select.innerHTML = '<option value="">All Operators</option>' + operators.map(op =>
            `<option value="${escapeHtml(op)}">${escapeHtml(op)}</option>`
          ).join('');
          select.value = currentValue;
        }
      });

      // Populate card selectors
      const cardSelectors = ['cardSelector', 'combinedCardSelector'];
      cardSelectors.forEach(selectorId => {
        const container = document.getElementById(selectorId);
        if (container) {
          container.innerHTML = '';
          for (let i = 1; i <= TOTAL_CARDS; i++) {
            const label = document.createElement('label');
            label.className = 'card-checkbox';
            label.innerHTML = `
            <input type="checkbox" value="${i}" onchange="applyFilters()">
            <span>Card ${i}</span>
          `;
            container.appendChild(label);
          }
        }
      });

      // Populate product selectors - get all unique products from saved tests
      const allProducts = new Set();
      saved.forEach(test => {
        const groups = groupData(test.cardRows || []);
        Object.keys(groups).forEach(p => {
          if (groups[p].allValues.length > 0) {
            allProducts.add(p);
          }
        });
      });
      const productList = Array.from(allProducts).sort();

      const productSelectors = ['filterProductSelector', 'cardProductSelector', 'combinedProductSelector'];
      productSelectors.forEach(selectorId => {
        const container = document.getElementById(selectorId);
        if (container) {
          container.innerHTML = '';
          productList.forEach(product => {
            const label = document.createElement('label');
            label.className = 'card-checkbox';
            label.innerHTML = `
            <input type="checkbox" value="${escapeHtml(product)}" onchange="applyFilters()">
            <span>${escapeHtml(product)}</span>
          `;
            container.appendChild(label);
          });
          // Add "Custom Product" option
          const customLabel = document.createElement('label');
          customLabel.className = 'card-checkbox';
          customLabel.innerHTML = `
          <input type="checkbox" value="__CUSTOM_PRODUCT__" onchange="applyFilters()">
          <span>Custom Product</span>
        `;
          container.appendChild(customLabel);
        }
      });
    }

    function openDetails(test) {
      detailsTest = test;

      document.getElementById('detailsPanel').style.display = 'block';
      document.getElementById('detailsTitle').textContent = `Report ${test.reportNumber} — Details`;
      document.getElementById('detailsMeta').innerHTML =
        `Date/Time: <strong>${escapeHtml(test.dateTime || '-')}</strong> | Test Date: <strong>${escapeHtml(test.testDate || '-')}</strong> | Operator: <strong>${escapeHtml(test.operatorName || '-')}</strong><br>` +
        `Targets: <strong>${escapeHtml(formatTargets(test.targets))}</strong>`;

      const groups = groupData(test.cardRows || []);
      const productsPresent = (test.productsPresent && test.productsPresent.length)
        ? test.productsPresent
        : Object.keys(groups);
      // Support both old format (single range) and new format (per-product ranges)
      const savedRanges = test.acceptableRanges || (test.acceptableRange !== undefined && test.acceptableRange !== null
        ? Object.fromEntries(productsPresent.map(p => [p, test.acceptableRange]))
        : Object.fromEntries(productsPresent.map(p => [p, 5.0])));

      renderGroupedCharts(groups, productsPresent.filter(p => groups[p] && groups[p].allValues.length > 0), 'detailsChartsGrid', detailsChartInstances, test.targets || {}, savedRanges);

      const t = document.getElementById('detailsTable');
      const targets = test.targets || {};
      t.innerHTML = `
      <thead>
        <tr>
          <th>Card #</th>
          <th>Product</th>
          <th>Target (g/m)</th>
          <th>Coiler 1</th>
          <th>Coiler 2</th>
          <th>Coiler 3</th>
          <th>Coiler 4</th>
          <th>Avg</th>
          <th>Min</th>
          <th>Max</th>
        </tr>
      </thead>
      <tbody>
        ${(test.cardRows || []).map(r => {
        const targetValue = (r.product && targets[r.product] !== null && targets[r.product] > 0)
          ? targets[r.product].toFixed(2)
          : '-';
        const coilers = (r.coilers || []).filter(v => v !== null && isFinite(v)).map(v => Number(v));
        const coilerMin = coilers.length > 0 ? Math.min(...coilers).toFixed(3) : '-';
        const coilerMax = coilers.length > 0 ? Math.max(...coilers).toFixed(3) : '-';
        return `
          <tr>
            <td><strong>${r.cardNo}</strong></td>
            <td>${escapeHtml(r.product || '')}</td>
            <td style="font-weight: 600; color: #2c3e50;">${targetValue}</td>
            ${(r.coilers || []).map(v => `<td>${v !== null && isFinite(v) ? Number(v).toFixed(3) : '-'}</td>`).join('')}
            <td><strong>${r.avg !== null && isFinite(r.avg) ? Number(r.avg).toFixed(3) : '-'}</strong></td>
            <td>${coilerMin}</td>
            <td>${coilerMax}</td>
          </tr>
        `;
      }).join('')}
      </tbody>
    `;
    }

    function closeDetails() {
      detailsTest = null;
      document.getElementById('detailsPanel').style.display = 'none';
      destroyChartMap(detailsChartInstances, 'detailsChartsGrid');
      document.getElementById('detailsTable').innerHTML = '';
    }

    // -----------------------------
    // Printing (multi-page, per product breaks)
    // -----------------------------
    function printDetails() {
      if (!detailsTest) return;
      printFromTests([detailsTest], `Saved Report ${detailsTest.reportNumber}`);
    }

    function printCurrent() {
      if (!currentTest) { alert('Please calculate results first.'); return; }
      printFromTestsWithTable([currentTest], `Current Test ${currentTest.reportNumber}`);
    }

    function printSelected() {
      const indices = getSelectedSavedIndices();
      if (indices.length === 0) { alert('Please select at least one saved test.'); return; }
      const saved = getSavedTests();
      const selectedTests = indices.map(i => saved[i]).filter(Boolean);
      printFromTests(selectedTests, `Selected Tests (${selectedTests.length})`);
    }

    function printFromTests(tests, modeLabel) {
      const printSection = document.getElementById('printSection');
      const printMeta = document.getElementById('printMeta');
      const printChartsContainer = document.getElementById('printChartsContainer');
      const printTablesContainer = document.getElementById('printTablesContainer');

      document.getElementById('printTitle').textContent = `Card Sliver Weight Monitoring — ${modeLabel}`;

      // Combine by product across tests for printing
      const combinedGroups = {};
      for (const t of tests) {
        const g = groupData(t.cardRows || []);
        for (const p of Object.keys(g)) {
          if (!combinedGroups[p]) combinedGroups[p] = { cardAvgs: [], allValues: [], cardNos: [] };
          combinedGroups[p].cardAvgs.push(...g[p].cardAvgs);
          combinedGroups[p].allValues.push(...g[p].allValues);
          combinedGroups[p].cardNos.push(...g[p].cardNos);
        }
      }
      const productsPresent = Object.keys(combinedGroups)
        .filter(p => combinedGroups[p].allValues.length > 0)
        .sort((a, b) => a.localeCompare(b));

      const reportNums = tests.map(t => t.reportNumber).filter(Boolean).join(', ');
      const testDates = Array.from(new Set(tests.map(t => t.testDate).filter(Boolean))).join(', ');
      const operators = Array.from(new Set(tests.map(t => t.operatorName).filter(Boolean))).join(', ');

      // Use the first test's range, or default to 5.0 if not available
      const printRange = (tests.length > 0 && tests[0].acceptableRange !== undefined && tests[0].acceptableRange !== null) ? tests[0].acceptableRange : 5.0;

      printMeta.innerHTML = `
      <div><strong>Report #:</strong> ${escapeHtml(reportNums || '-')}</div>
      <div><strong>Date(s):</strong> ${escapeHtml(testDates || '-')}</div>
      <div><strong>Operator(s):</strong> ${escapeHtml(operators || '-')}</div>
      <div><strong>Products:</strong> ${escapeHtml(productsPresent.join(', ') || '-')}</div>
    `;

      // Calculate per-product metrics for print header
      const printMetricsData = {};
      const printRanges = {}; // Per-product ranges

      for (const p of productsPresent) {
        const g = combinedGroups[p];
        printMetricsData[p] = { totalCards: g.cardAvgs.length, totalCoilers: g.allValues.length, oocCards: 0, oocCoilers: 0 };

        // Determine range for this product (use per-product range if available, otherwise use single range)
        let productRange = printRange;
        for (const t of tests) {
          if (t.acceptableRanges && t.acceptableRanges[p] !== undefined && t.acceptableRanges[p] !== null) {
            productRange = t.acceptableRanges[p];
            break;
          } else if (t.acceptableRange !== undefined && t.acceptableRange !== null && tests.length === 1) {
            productRange = t.acceptableRange;
          }
        }
        printRanges[p] = productRange;

        // Calculate OOC for this product from all tests
        for (const t of tests) {
          const testGroups = groupData(t.cardRows || []);
          if (!testGroups[p]) continue;

          const tgt = t.targets && t.targets[p] ? t.targets[p] : null;
          const meanCard = meanOf(testGroups[p].cardAvgs);
          const limCard = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(testGroups[p].allValues);
          const limCoiler = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanAll, productRange);

          for (const r of t.cardRows || []) {
            if ((r.product || '').trim() !== p) continue;
            if (r.avg !== null && isFinite(r.avg) && !withinLimits(Number(r.avg), limCard)) {
              printMetricsData[p].oocCards++;
            }
            for (const v of (r.coilers || [])) {
              if (v !== null && isFinite(v) && !withinLimits(Number(v), limCoiler)) {
                printMetricsData[p].oocCoilers++;
              }
            }
          }
        }
      }

      // Create metrics boxes for print with inline styles for color printing - per product
      const printMetrics = document.getElementById('printMetrics');
      let printMetricsHTML = `
      <div class="print-metric" style="background-color: #3498db !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
        <div class="label">Products Detected</div>
        <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
      </div>
    `;

      for (const p of productsPresent) {
        const metrics = printMetricsData[p];
        const g = combinedGroups[p];
        const rangeStr = printRanges[p].toFixed(1);
        const cardsBgColor = metrics.oocCards > 0 ? '#e74c3c' : '#3498db';
        const coilersBgColor = metrics.oocCoilers > 0 ? '#e74c3c' : '#3498db';

        const cardMin = g.cardAvgs && g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs).toFixed(2) : '-';
        const cardMax = g.cardAvgs && g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs).toFixed(2) : '-';
        const coilerMin = g.allValues && g.allValues.length > 0 ? Math.min(...g.allValues).toFixed(3) : '-';
        const coilerMax = g.allValues && g.allValues.length > 0 ? Math.max(...g.allValues).toFixed(3) : '-';

        printMetricsHTML += `
        <div class="print-metric" style="background-color: ${cardsBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCards} out of ${metrics.totalCards}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
        </div>
        <div class="print-metric" style="background-color: ${coilersBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCoilers} out of ${metrics.totalCoilers}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${coilerMin} | Max: ${coilerMax}</div>
        </div>
      `;
      }

      printMetrics.innerHTML = printMetricsHTML;

      printChartsContainer.innerHTML = '';
      printTablesContainer.innerHTML = '';

      // Destroy old print charts
      for (const ch of printChartInstances.values()) ch.destroy();
      printChartInstances.clear();

      // Charts grid
      const grid = document.createElement('div');
      grid.className = 'print-grid';
      printChartsContainer.appendChild(grid);

      // For combined printing, there is no single target per product (targets may differ per test),
      // so we only show target line when printing exactly one test.
      const singleTestTargets = (tests.length === 1 && tests[0].targets) ? tests[0].targets : {};

      for (let i = 0; i < productsPresent.length; i++) {
        const p = productsPresent[i];
        const g = combinedGroups[p];

        // Only show All Coiler Readings chart (not Card Averages)
        if (g.allValues.length > 0) {
          const id = `print_all_${safeId(p)}`;
          grid.appendChild(makePrintChartCard(`${p} — All Coiler Readings`, id));
          const mean = meanOf(g.allValues);
          const { lcl, ucl } = limitsFromMean(mean, printRange);
          const tval = (tests.length === 1 && singleTestTargets[p] !== null && isFinite(singleTestTargets[p])) ? singleTestTargets[p] : null;
          plotDistribution(id, g.allValues, mean, lcl, ucl, `Product: ${p} (All Coiler Readings)`, printChartInstances, tval);
        }

        // Remove page breaks between products to save pages - only break if needed for layout
      }

      // Combined summary table (mean-based)
      const summary = document.createElement('div');
      summary.innerHTML = `<h3 style="margin: 6px 0; font-size: 14px;">Combined Summary by Product</h3>`;
      const table = document.createElement('table');
      table.innerHTML = `
      <thead>
        <tr>
          <th>Product</th>
          <th># Card Avgs</th>
          <th># Coiler Values</th>
          <th>Mean (Card Avg)</th>
          <th>LCL (Card Avg)</th>
          <th>UCL (Card Avg)</th>
          <th>Mean (All)</th>
          <th>LCL (All)</th>
          <th>UCL (All)</th>
        </tr>
      </thead>
      <tbody>
        ${productsPresent.map(p => {
        const g = combinedGroups[p];
        const cardMean = g.cardAvgs.length ? meanOf(g.cardAvgs) : null;
        const cardLim = cardMean !== null ? limitsFromMean(cardMean, printRange) : { lcl: null, ucl: null };
        const allMean = g.allValues.length ? meanOf(g.allValues) : null;
        const allLim = allMean !== null ? limitsFromMean(allMean, printRange) : { lcl: null, ucl: null };
        return `
            <tr>
              <td><strong>${escapeHtml(p)}</strong></td>
              <td>${g.cardAvgs.length}</td>
              <td>${g.allValues.length}</td>
              <td>${cardMean === null ? '-' : cardMean.toFixed(2)}</td>
              <td>${cardLim.lcl === null ? '-' : cardLim.lcl.toFixed(2)}</td>
              <td>${cardLim.ucl === null ? '-' : cardLim.ucl.toFixed(2)}</td>
              <td>${allMean === null ? '-' : allMean.toFixed(3)}</td>
              <td>${allLim.lcl === null ? '-' : allLim.lcl.toFixed(3)}</td>
              <td>${allLim.ucl === null ? '-' : allLim.ucl.toFixed(3)}</td>
            </tr>
          `;
      }).join('')}
      </tbody>
    `;
      summary.appendChild(table);
      printTablesContainer.appendChild(summary);

      // Show print view (static flow; multi-page supported)
      const mainContainer = document.querySelector('.container');
      const originalDisplay = mainContainer ? mainContainer.style.display : '';

      if (mainContainer) mainContainer.style.display = 'none';
      printSection.style.cssText = `
      display:block !important;
      visibility:visible !important;
      position:static !important;
      left:auto !important;
      top:auto !important;
      width:100% !important;
      height:auto !important;
      background:white !important;
      z-index:99999 !important;
      overflow:visible !important;
      padding:20px !important;
    `;

      const restore = () => {
        printSection.style.cssText = 'display:none; position:absolute; left:-9999px; top:0;';
        if (mainContainer) mainContainer.style.display = originalDisplay || 'block';
        for (const ch of printChartInstances.values()) ch.destroy();
        printChartInstances.clear();
      };

      window.scrollTo(0, 0);
      setTimeout(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try { window.print(); } catch (e) { alert('Print failed. Use Ctrl+P / Cmd+P.'); restore(); return; }
            const after = () => { restore(); window.removeEventListener('afterprint', after); };
            window.addEventListener('afterprint', after);
            setTimeout(restore, 1400);
          });
        });
      }, 600);
    }

    function makePrintChartCard(title, canvasId) {
      const wrap = document.createElement('div');
      wrap.className = 'avoid-break';
      wrap.style.border = '1px solid #e5e7eb';
      wrap.style.borderRadius = '8px';
      wrap.style.padding = '6px';
      wrap.style.boxShadow = '0 1px 6px rgba(0,0,0,0.06)';

      const h = document.createElement('h3');
      h.textContent = title;
      h.style.margin = '0 0 4px';
      h.style.fontSize = '13px';
      h.style.fontWeight = 'bold';
      wrap.appendChild(h);

      const canvas = document.createElement('canvas');
      canvas.id = canvasId;
      wrap.appendChild(canvas);

      return wrap;
    }

    // -----------------------------
    // Export Functions (Excel & PDF)
    // -----------------------------
    function exportToExcel() {
      try {
        const saved = getSavedTests();
        const indices = getSelectedSavedIndices();

        // Determine which tests to export
        let testsToExport = [];
        if (indices.length > 0) {
          // Export selected tests
          testsToExport = indices.map(i => saved[i]).filter(Boolean);
        } else if (filteredTests.length > 0) {
          // Export filtered tests
          testsToExport = filteredTests;
        } else {
          // Export all tests
          testsToExport = saved;
        }

        if (testsToExport.length === 0) {
          alert('No tests to export.');
          return;
        }

        // Create workbook
        const wb = XLSX.utils.book_new();

        // Summary sheet
        const summaryData = [
          ['Date & Time', 'Report #', 'Test Date', 'Operator', 'Targets Entered', 'Product Summary (Avg)', 'OOC Cards', 'OOC Coilers']
        ];

        testsToExport.forEach(test => {
          const summary = formatProductSummary(test.summaryByProduct);
          const targetsText = formatTargets(test.targets);
          summaryData.push([
            test.dateTime || 'N/A',
            test.reportNumber || 'N/A',
            test.testDate || 'N/A',
            test.operatorName || 'N/A',
            targetsText,
            summary,
            test.oocCardsAll || 0,
            test.oocCoilersAll || 0
          ]);
        });

        const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
        XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

        // Detailed data sheet
        const detailedData = [
          ['Test Date', 'Report #', 'Operator', 'Card #', 'Product', 'Target (g/m)', 'Coiler 1', 'Coiler 2', 'Coiler 3', 'Coiler 4', 'Avg', 'Min', 'Max']
        ];

        testsToExport.forEach(test => {
          const targets = test.targets || {};
          (test.cardRows || []).forEach(row => {
            const coilers = row.coilers || [];
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            const minVal = coilerValues.length > 0 ? Math.min(...coilerValues) : null;
            const maxVal = coilerValues.length > 0 ? Math.max(...coilerValues) : null;
            const targetValue = (row.product && targets[row.product] !== null && targets[row.product] > 0)
              ? targets[row.product]
              : null;

            detailedData.push([
              test.testDate || 'N/A',
              test.reportNumber || 'N/A',
              test.operatorName || 'N/A',
              row.cardNo,
              row.product || '',
              targetValue !== null ? targetValue : '',
              coilers[0] !== null && isFinite(coilers[0]) ? coilers[0] : '',
              coilers[1] !== null && isFinite(coilers[1]) ? coilers[1] : '',
              coilers[2] !== null && isFinite(coilers[2]) ? coilers[2] : '',
              coilers[3] !== null && isFinite(coilers[3]) ? coilers[3] : '',
              row.avg !== null && isFinite(row.avg) ? row.avg : '',
              minVal !== null ? minVal : '',
              maxVal !== null ? maxVal : ''
            ]);
          });
        });

        const wsDetailed = XLSX.utils.aoa_to_sheet(detailedData);
        XLSX.utils.book_append_sheet(wb, wsDetailed, 'Detailed Data');

        // Per-product statistics sheet
        const statsData = [
          ['Test Date', 'Report #', 'Product', 'Target (g/m)', 'Range (%)', 'Cards Count', 'Coilers Count', 'Card Avg Mean', 'Card Avg LCL', 'Card Avg UCL', 'All Mean', 'All LCL', 'All UCL', 'OOC Cards', 'OOC Coilers']
        ];

        testsToExport.forEach(test => {
          const groups = groupData(test.cardRows || []);
          const productsPresent = Object.keys(groups).filter(p => groups[p].allValues.length > 0);
          const ranges = test.acceptableRanges || (test.acceptableRange !== undefined && test.acceptableRange !== null
            ? Object.fromEntries(productsPresent.map(p => [p, test.acceptableRange]))
            : Object.fromEntries(productsPresent.map(p => [p, 5.0])));
          const targets = test.targets || {};

          productsPresent.forEach(product => {
            const g = groups[product];
            const productRange = ranges[product] || 5.0;
            const meanCard = meanOf(g.cardAvgs);
            const limCardMean = limitsFromMean(meanCard, productRange);
            const meanAll = meanOf(g.allValues);
            const limAllMean = limitsFromMean(meanAll, productRange);
            const tgt = targets[product] || null;

            const stats = test.productStats && test.productStats[product] ? test.productStats[product] : {
              oocCards: 0,
              oocCoilers: 0
            };

            statsData.push([
              test.testDate || 'N/A',
              test.reportNumber || 'N/A',
              product,
              tgt !== null ? tgt : '',
              productRange,
              g.cardAvgs.length,
              g.allValues.length,
              meanCard,
              limCardMean.lcl,
              limCardMean.ucl,
              meanAll,
              limAllMean.lcl,
              limAllMean.ucl,
              stats.oocCards || 0,
              stats.oocCoilers || 0
            ]);
          });
        });

        const wsStats = XLSX.utils.aoa_to_sheet(statsData);
        XLSX.utils.book_append_sheet(wb, wsStats, 'Product Statistics');

        // Generate filename
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `Card_Sliver_Weight_Export_${timestamp}.xlsx`;

        // Write file
        XLSX.writeFile(wb, filename);

        alert(`Exported ${testsToExport.length} test(s) to Excel successfully.`);
      } catch (e) {
        showError("Excel export failed: " + (e && e.message ? e.message : String(e)));
        console.error(e);
      }
    }

    function exportToPDF() {
      try {
        const saved = getSavedTests();
        const indices = getSelectedSavedIndices();

        // Determine which tests to export
        let testsToExport = [];
        if (indices.length > 0) {
          // Export selected tests
          testsToExport = indices.map(i => saved[i]).filter(Boolean);
        } else if (filteredTests.length > 0) {
          // Export filtered tests
          testsToExport = filteredTests;
        } else {
          // Export all tests
          testsToExport = saved;
        }

        if (testsToExport.length === 0) {
          alert('No tests to export.');
          return;
        }

        // Check if jsPDF is available
        let jsPDF;
        if (typeof window.jspdf !== 'undefined' && window.jspdf.jsPDF) {
          jsPDF = window.jspdf.jsPDF;
        } else if (typeof window.jsPDF !== 'undefined') {
          jsPDF = window.jsPDF;
        } else {
          alert('PDF library not loaded. Please refresh the page.');
          return;
        }
        const doc = new jsPDF('p', 'mm', 'a4');
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const maxWidth = pageWidth - (margin * 2);
        let yPos = margin;

        // Helper function to add a new page if needed
        function checkPageBreak(requiredHeight = 20) {
          if (yPos + requiredHeight > pageHeight - margin) {
            doc.addPage();
            yPos = margin;
            return true;
          }
          return false;
        }

        // Helper function to add text with word wrap
        function addText(text, x, y, maxWidth, fontSize = 10, fontStyle = 'normal') {
          doc.setFontSize(fontSize);
          doc.setFont('helvetica', fontStyle);
          const lines = doc.splitTextToSize(text, maxWidth);
          doc.text(lines, x, y);
          return lines.length * (fontSize * 0.35); // Approximate line height
        }

        // Title
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.text('Card Sliver Weight Monitoring - Export', margin, yPos);
        yPos += 10;

        // Export info
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        const exportDate = new Date().toLocaleString();
        doc.text(`Exported: ${exportDate}`, margin, yPos);
        doc.text(`Tests: ${testsToExport.length}`, pageWidth - margin - 30, yPos);
        yPos += 8;

        // Summary table
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text('Summary', margin, yPos);
        yPos += 8;

        // Table headers
        const tableHeaders = ['Date/Time', 'Report #', 'Test Date', 'Operator', 'OOC Cards', 'OOC Coilers'];
        const colWidths = [35, 25, 30, 35, 25, 25];
        const startX = margin;

        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        let xPos = startX;
        tableHeaders.forEach((header, idx) => {
          doc.text(header, xPos, yPos);
          xPos += colWidths[idx];
        });
        yPos += 6;

        // Table rows
        doc.setFont('helvetica', 'normal');
        testsToExport.forEach((test, idx) => {
          checkPageBreak(10);

          if (idx > 0 && idx % 20 === 0) {
            // Add header again every 20 rows
            doc.setFont('helvetica', 'bold');
            xPos = startX;
            tableHeaders.forEach((header, hIdx) => {
              doc.text(header, xPos, yPos);
              xPos += colWidths[hIdx];
            });
            yPos += 6;
            doc.setFont('helvetica', 'normal');
          }

          xPos = startX;
          const rowData = [
            (test.dateTime || 'N/A').substring(0, 15),
            test.reportNumber || 'N/A',
            (test.testDate || 'N/A').substring(0, 10),
            (test.operatorName || 'N/A').substring(0, 15),
            String(test.oocCardsAll || 0),
            String(test.oocCoilersAll || 0)
          ];

          rowData.forEach((cell, cellIdx) => {
            doc.text(cell, xPos, yPos);
            xPos += colWidths[cellIdx];
          });
          yPos += 6;
        });

        yPos += 5;

        // Detailed data for each test
        testsToExport.forEach((test, testIdx) => {
          checkPageBreak(30);

          // Test header
          yPos += 5;
          doc.setFontSize(11);
          doc.setFont('helvetica', 'bold');
          doc.text(`Test ${testIdx + 1}: Report #${test.reportNumber}`, margin, yPos);
          yPos += 6;

          doc.setFontSize(9);
          doc.setFont('helvetica', 'normal');
          doc.text(`Date: ${test.testDate || 'N/A'} | Operator: ${test.operatorName || 'N/A'}`, margin, yPos);
          yPos += 5;

          doc.text(`Targets: ${formatTargets(test.targets)}`, margin, yPos);
          yPos += 5;

          // Detailed table for this test
          const detailHeaders = ['Card', 'Product', 'Target', 'C1', 'C2', 'C3', 'C4', 'Avg', 'Min', 'Max'];
          const detailColWidths = [12, 25, 15, 15, 15, 15, 15, 15, 15, 15];
          const detailStartX = margin;

          doc.setFont('helvetica', 'bold');
          xPos = detailStartX;
          detailHeaders.forEach((header, hIdx) => {
            doc.text(header, xPos, yPos);
            xPos += detailColWidths[hIdx];
          });
          yPos += 5;

          doc.setFont('helvetica', 'normal');
          const targets = test.targets || {};
          (test.cardRows || []).forEach(row => {
            checkPageBreak(6);

            const coilers = row.coilers || [];
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            const minVal = coilerValues.length > 0 ? Math.min(...coilerValues) : null;
            const maxVal = coilerValues.length > 0 ? Math.max(...coilerValues) : null;
            const targetValue = (row.product && targets[row.product] !== null && targets[row.product] > 0)
              ? targets[row.product].toFixed(2)
              : '-';

            xPos = detailStartX;
            const detailRow = [
              String(row.cardNo),
              (row.product || '').substring(0, 12),
              targetValue,
              coilers[0] !== null && isFinite(coilers[0]) ? coilers[0].toFixed(3) : '-',
              coilers[1] !== null && isFinite(coilers[1]) ? coilers[1].toFixed(3) : '-',
              coilers[2] !== null && isFinite(coilers[2]) ? coilers[2].toFixed(3) : '-',
              coilers[3] !== null && isFinite(coilers[3]) ? coilers[3].toFixed(3) : '-',
              row.avg !== null && isFinite(row.avg) ? row.avg.toFixed(2) : '-',
              minVal !== null ? minVal.toFixed(3) : '-',
              maxVal !== null ? maxVal.toFixed(3) : '-'
            ];

            detailRow.forEach((cell, cellIdx) => {
              doc.text(cell, xPos, yPos);
              xPos += detailColWidths[cellIdx];
            });
            yPos += 5;
          });

          yPos += 3;
        });

        // Generate filename
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `Card_Sliver_Weight_Export_${timestamp}.pdf`;

        // Save PDF
        doc.save(filename);

        alert(`Exported ${testsToExport.length} test(s) to PDF successfully.`);
      } catch (e) {
        showError("PDF export failed: " + (e && e.message ? e.message : String(e)));
        console.error(e);
      }
    }

    // -----------------------------
    // Utilities
    // -----------------------------
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (m) => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
      }[m]));
    }
    function safeId(s) {
      return String(s).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
    }

    // -----------------------------
    // RS-232 Scale Integration
    // -----------------------------
    async function initScaleConnection() {
      // Check if Web Serial API is available
      if (!navigator.serial) {
        showScaleStatus('Web Serial API not supported in this browser. Please enter values manually.', 'warning');
        return;
      }

      try {
        // Request port access
        scalePort = await navigator.serial.requestPort();

        // Open port with common scale settings: 9600 baud, 8N1
        await scalePort.open({ baudRate: 9600, dataBits: 8, parity: 'none', stopBits: 1 });

        scaleConnected = true;
        showScaleStatus('Scale connected. Reading weight values...', 'success');
        const btn = document.getElementById('scaleBtn');
        if (btn) btn.textContent = 'Disconnect Scale';

        // Start reading from scale
        readScaleData();
      } catch (error) {
        if (error.name === 'NotFoundError' || error.name === 'SecurityError') {
          // User cancelled or permission denied
          showScaleStatus('Scale not detected. Please enter values manually.', 'info');
        } else {
          showScaleStatus('Scale connection error. Please enter values manually.', 'warning');
          console.error('Scale error:', error);
        }
        scaleConnected = false;
      }
    }

    async function readScaleData() {
      if (!scalePort || !scaleConnected) return;

      try {
        const decoder = new TextDecoder();
        scaleReader = scalePort.readable.getReader();

        while (scaleConnected && scalePort.readable) {
          const { value, done } = await scaleReader.read();
          if (done) break;

          const text = decoder.decode(value);
          // Parse scale data - common formats: "4.567\r\n" or "ST,+04.567 kg\r\n" or just numbers
          const matches = text.match(/[\d.]+/g);
          if (matches && matches.length > 0) {
            const weight = parseFloat(matches[0]);
            if (!isNaN(weight) && weight > 0) {
              currentScaleValue = weight;
              // Update the focused input field if any
              const activeElement = document.activeElement;
              if (activeElement && activeElement.type === 'number' && activeElement.id.startsWith('coiler_')) {
                activeElement.value = weight.toFixed(3);
                // Trigger change event
                const event = new Event('change', { bubbles: true });
                activeElement.dispatchEvent(event);
              }
            }
          }
        }
      } catch (error) {
        if (scaleConnected) {
          showScaleStatus('Scale reading error. Please enter values manually.', 'warning');
          console.error('Scale read error:', error);
        }
        scaleConnected = false;
      } finally {
        if (scaleReader) {
          scaleReader.releaseLock();
          scaleReader = null;
        }
      }
    }

    async function disconnectScale() {
      scaleConnected = false;
      if (scaleReader) {
        try {
          await scaleReader.cancel();
        } catch (e) { }
        try {
          scaleReader.releaseLock();
        } catch (e) { }
        scaleReader = null;
      }
      if (scalePort) {
        try {
          await scalePort.close();
        } catch (e) { }
        scalePort = null;
      }
      showScaleStatus('Scale disconnected. Please enter values manually.', 'info');
      const btn = document.getElementById('scaleBtn');
      if (btn) btn.textContent = 'Connect Scale';
    }

    function showScaleStatus(message, type) {
      const statusEl = document.getElementById('scaleStatus');
      if (!statusEl) return;

      statusEl.style.display = 'block';
      statusEl.textContent = message;

      // Set color based on type
      statusEl.style.background = type === 'success' ? '#d4edda' :
        type === 'warning' ? '#fff3cd' :
          '#d1ecf1';
      statusEl.style.color = type === 'success' ? '#155724' :
        type === 'warning' ? '#856404' :
          '#0c5460';
      statusEl.style.border = `1px solid ${type === 'success' ? '#c3e6cb' :
        type === 'warning' ? '#ffeaa7' :
          '#bee5eb'}`;
    }

    function handleCoilerFocus(cardNo, coilerNo) {
      // When a coiler input is focused, we're ready to receive scale data
      // The scale data will automatically populate when received
    }

    // Add button to connect/disconnect scale
    window.connectScale = async function () {
      const btn = document.getElementById('scaleBtn');
      if (scaleConnected) {
        await disconnectScale();
        if (btn) btn.textContent = 'Connect Scale';
      } else {
        if (btn) btn.textContent = 'Connecting...';
        await initScaleConnection();
        if (btn) btn.textContent = scaleConnected ? 'Disconnect Scale' : 'Connect Scale';
      }
    };
  </script>
</body>

</html>